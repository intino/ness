def type(datamart & interface)
	package $package;

	import io.intino.alexandria.Timetag;

	import java.util.List;
	import java.util.Map;
	import java.util.concurrent.ConcurrentHashMap;
	import java.util.stream.Stream;
	import java.util.stream.Collectors;

	import io.intino.ness.master.Datamart;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.reflection.*;

	public interface $name+FirstUpperCase~Datamart extends Datamart {

		$name+FirstUpperCase~DatamartImpl.$name+FirstUpperCase~DatamartDefinition definition = new $name+FirstUpperCase~DatamartImpl.$name+FirstUpperCase~DatamartDefinition();

		List<Timetag> listSnapshots();

		$name+FirstUpperCase~Datamart snapshot(Timetag timetag);

		$entity+getterSignature...[$NL$NL]

		class Entities {

			private final $name+FirstUpperCase~Datamart datamart;
			private final Map<EntityDefinition, Map<String, $name+FirstUpperCase~Entity>> entitiesByType;

			public Entities($name+FirstUpperCase~Datamart datamart) {
				this.datamart = datamart;
				this.entitiesByType = new ConcurrentHashMap<>();
				datamart.getDefinition().entities().forEach(entity -> entitiesByType.put(entity, new ConcurrentHashMap<>()));
			}

			public $name+FirstUpperCase~Datamart datamart() {
				return datamart;
			}

        	public int size() {
        		return entitiesByType.values().stream().mapToInt(Map::size).sum();
        	}

        	public $name+FirstUpperCase~Entity get(String id) {
        		return mapOf(id).map(map -> map.get(id)).orElse(null);
        	}

			@SuppressWarnings("unchecked")
        	public <T extends $name+FirstUpperCase~Entity> T get(EntityDefinition type, String id) {
        		return (T) entitiesByType.get(type).get(id);
            }

        	public void add($name+FirstUpperCase~Entity entity) {
        		entitiesByType.get(entity.getDefinition()).put(entity.id(), entity);
        	}

        	public void remove(String id) {
        		mapOf(id).ifPresent(map -> map.remove(id));
        	}

        	public Stream<$name+FirstUpperCase~Entity> stream() {
        		return entitiesByType.values().stream().flatMap(map -> map.values().stream());
        	}

			@SuppressWarnings("unchecked")
        	public <T extends $name+FirstUpperCase~Entity> Stream<T> stream(EntityDefinition type) {
        		return (Stream<T>) entitiesByType.entrySet().stream()
        			.filter(e -> e.getKey().equals(type) || e.getKey().isDescendantOf(type))
        			.flatMap(e -> e.getValue().values().stream());
        	}

        	public Stream<Entity> streamGeneric() {
            	return entitiesByType.values().stream().flatMap(map -> map.values().stream());
            }

        	private java.util.Optional<Map<String, $name+FirstUpperCase~Entity>> mapOf(String id) {
        		return entitiesByType.values().stream().filter(map -> map.containsKey(id)).findFirst();
        	}
        }
	}
end

def type(datamart & message & impl)
	package $package;

	import io.intino.alexandria.Timetag;
	import io.intino.alexandria.event.Event;
	import io.intino.alexandria.logger.Logger;
	import io.intino.alexandria.terminal.Connector;
	import io.intino.ness.master.reflection.*;
	import io.intino.ness.master.model.Entity;

	import org.apache.activemq.command.ActiveMQTextMessage;

	import java.util.ArrayList;
	import java.util.List;
	import java.util.Optional;
	import java.util.concurrent.atomic.AtomicBoolean;
	import java.util.stream.Stream;
	import java.util.stream.Collectors;

	import static java.util.Objects.requireNonNull;

	public class $name+FirstUpperCase~DatamartImpl implements $name+FirstUpperCase~Datamart {

		private static final String DATAHUB_MESSAGE_TOPIC = "service.ness.datalake.messagestore";

		private final Connector connector;
		private final AtomicBoolean initialized = new AtomicBoolean(false);
		private final List<EntityListener> entityListeners = new ArrayList<>();
		private final $name+FirstUpperCase~Datamart.Entities entities;

    	public $name+FirstUpperCase~DatamartImpl(Connector connector) {
    		this.connector = requireNonNull(connector);
    		this.entities = new $name+FirstUpperCase~Datamart.Entities(this);
    	}

		public synchronized $name+FirstUpperCase~DatamartImpl init() {
			try {
				if(!initialized.compareAndSet(false, true)) return this;
				downloadDatamartFromDatahub();
				Logger.info("$name+FirstUpperCase~Datamart (" + (snapshotTimetag().isEmpty() ? "" : "snapshot " + snapshotTimetag() + ", ")  + connector.clientId() + ") initialized successfully.");
			} catch(Exception e) {
				throw new ExceptionInInitializerError("Entities failed to start because a " + e.getClass().getName() + " occurred: " + e.getMessage());
			}
			return this;
		}

		@Override
		public int size() {
			return entities.size();
		}

		@Override
		@SuppressWarnings("unchecked")
		public <T extends Entity> T get(String id) {
			return (T) entities.get(id);
		}

		@Override
		public Stream<Entity> entities() {
			return entities.streamGeneric();
		}

		@Override
		public void addEntityListener(EntityListener listener) {
			if(listener == null) throw new NullPointerException("EntityListener cannot be null");
			entityListeners.add(listener);
		}

		@Override
		public DatamartDefinition getDefinition() {
			return definition;
		}

		@Override
        public List<Timetag> listSnapshots() {
        	try {
        		javax.jms.Message message = connector.requestResponse(DATAHUB_MESSAGE_TOPIC, listSnapshotsRequest());
        		return handleListSnapshotsResponse(message);
        	} catch (Exception e) {
        		Logger.error("Could not download list of available snapshots: " + e.getMessage(), e);
        		return java.util.Collections.emptyList();
        	}
        }

        private javax.jms.Message listSnapshotsRequest() throws Exception {
        	ActiveMQTextMessage message = new ActiveMQTextMessage();
        	message.setText("datamart:" + name() + ":snapshots");
        	return message;
        }

        private List<Timetag> handleListSnapshotsResponse(javax.jms.Message message) throws Exception {
        	return java.util.Arrays.stream(((javax.jms.TextMessage) message).getText().split(",")).map(Timetag::of).collect(Collectors.toList());
        }

        @Override
        public synchronized $name+FirstUpperCase~Datamart snapshot(Timetag timetag) {
        	if(timetag == null) return this;
        	return new $name+FirstUpperCase~DatamartImpl(connector) {
        		@Override
        		protected String snapshotTimetag() {
        			return timetag.value();
        		}
        		@Override
        		public synchronized MasterDatamart snapshot(Timetag timetag) {
        			if(timetag == null) return $name+FirstUpperCase~DatamartImpl.this;
        			return snapshotTimetag().equals(timetag.value()) ? this : super.snapshot(timetag);
        		}
        	}.init();
        }

    	$entity+getter...[$NL$NL]

		private void downloadDatamartFromDatahub() {
			Logger.debug("Downloading datamart from datahub...");
    		long start = java.lang.System.currentTimeMillis();
			loadEntitiesFromEvents(downloadEvents());
			long time = java.lang.System.currentTimeMillis() - start;
			Logger.debug("Datamart downloaded from datahub after " + time + " ms");
		}

		private Stream<Event> downloadEvents() {
			try {
				javax.jms.Message message = connector.requestResponse(DATAHUB_MESSAGE_TOPIC, downloadRequest());
				return handleDownloadResponse(message);
			} catch (NullPointerException e) {
				throw new RuntimeException("Could not download datamart: no response from datahub.");
			} catch (Exception e) {
				throw new RuntimeException("Could not download datamart: " + e.getMessage());
			}
		}

		private javax.jms.Message downloadRequest() throws Exception {
			ActiveMQTextMessage message = new ActiveMQTextMessage();
			message.setText("datamart:" + name() + ":" + snapshotTimetag());
			return message;
		}

		protected String snapshotTimetag() {
			return "";
		}

		private Stream<Event> handleDownloadResponse(javax.jms.Message message) throws Exception {
			javax.jms.BytesMessage m = (javax.jms.BytesMessage) message;
			int size = m.getIntProperty("content-size");
			byte$[$] bytes = new byte$[size$];
			m.readBytes(bytes, size);
			return io.intino.alexandria.zim.ZimStream.of(new java.io.ByteArrayInputStream(bytes)).map(io.intino.alexandria.event.message.MessageEvent::new);
		}

		private void loadEntitiesFromEvents(Stream<Event> events) {
			if(availableThreads() >= 4)
				events.forEach(this::mount);
			else
				events.parallel().forEach(this::mount);
		}

		public void mount(Event event) {
			switch(event.type()) {
				[$entity+mountSwitchCase...[$NL]]
			}
		}

		private static int availableThreads() {
			return Runtime.getRuntime().availableProcessors();
		}

		// WARNING: extremely compacted and ugly code ahead... continue at your own discretion.

		public static final class $name+FirstUpperCase~DatamartDefinition implements DatamartDefinition {

			@Override
			public String name() {
				return "$name";
			}

			@Override
			public Scale scale() {
				return Scale.$scale;
			}

			@Override
			public Query<EntityDefinition> entities() {
				return new Query<>(List.of([$entity+definition...[,]]));
			}

			@Override
			public Query<StructDefinition> structs() {
				return new Query<>(List.of([$struct+definition...[,]]));
			}

			@Override
			public Optional<EntityDefinition> entity(String name) {
				switch(name) {
					[$entity+defSwitchCase...[$NL]]
				}
				return Optional.empty();
			}

			@Override
        	public Optional<StructDefinition> struct(String name) {
        		switch(name) {
        			[$struct+defSwitchCase...[$NL]]
        		}
        		return Optional.empty();
        	}

			private $name+FirstUpperCase~DatamartDefinition datamart() {
				return this;
			}

			[$entity+declareDefinition...[$NL]]

			// Seriously why the heck are you reading this?? Are you a masochist or what

            [$struct+declareDefinition...[$NL]]
		}
    }
end

def type(entity) trigger(definition)
	$name+firstLowerCase~EntityDefinition
end

def type(struct) trigger(definition)
	$name+firstLowerCase~StructDefinition
end

def type(entity) trigger(defSwitchCase)
	case "$name+FirstUpperCase": return Optional.of($name+firstLowerCase~EntityDefinition);
end

def type(struct) trigger(defSwitchCase)
	case "$name+FirstUpperCase": return Optional.of($name+firstLowerCase~StructDefinition);
end

def type(entity) trigger(declareDefinition)
	public final EntityDefinition $name+firstLowerCase~EntityDefinition = new EntityDefinition() {
		private final List<AttributeDefinition> declaredAttributes = initAttributeDefinitions();
		public String fullName() {return "$fullName";}
		public String name() {return "$name";}
		public boolean isAbstract() {return $isAbstract;}
		public List<AttributeDefinition> declaredAttributes() {	return declaredAttributes;}
		public Optional<EntityDefinition> parent() {return datamart().entity("$parent");}
		public List<EntityDefinition> descendants() {return datamart().entities().instanceOf(this);}
		public Class<?> javaClass() {return $package.entities.$name+FirstUpperCase.class;}
		private List<AttributeDefinition> initAttributeDefinitions() {
			List<AttributeDefinition> list = new ArrayList<>($numAttributes);
        	[$attribute+addDefinition...[$NL]]
        	return list;
		}
		public boolean equals(Object other) {
			if(other == null || other.getClass() != getClass()) return false;
			return fullName().equals(((EntityDefinition)other).fullName());
		}
		public int hashCode() {return fullName().hashCode();}
		public String toString() {return fullName();}
	};
end

def type(struct) trigger(declareDefinition)
	public final StructDefinition $name+FirstUpperCase~StructDefinition = new StructDefinition() {
		private final List<AttributeDefinition> declaredAttributes = initAttributeDefinitions();
		public String fullName() {return "$fullName";}
		public String name() {return "$name";}
		public List<AttributeDefinition> declaredAttributes() {return declaredAttributes;}
		public Optional<StructDefinition> parent() {return datamart().struct("$parent");}
		public List<StructDefinition> descendants() {return datamart().structs().instanceOf(this);}
		public Class<?> javaClass() {return $package.structs.$name+FirstUpperCase.class;}
		private List<AttributeDefinition> initAttributeDefinitions() {
			List<AttributeDefinition> list = new ArrayList<>($numAttributes);
        	[$attribute+addDefinition...[$NL]]
        	return list;
		}
		public boolean equals(Object other) {
        	if(other == null || other.getClass() != getClass()) return false;
        	return fullName().equals(((StructDefinition)other).fullName());
        }
        public int hashCode() {return fullName().hashCode();}
        public String toString() {return fullName();}
	};
end

def type(subclass) trigger(name)
	"$name+FirstUpperCase"
end

def type(attribute) type(collection) trigger(addDefinition)
	list.add(new AttributeDefinition() {
		public String name() {return "$name";}
		public Class<?> type() {return $type~.class;}
		public List<ParameterDefinition> parameters() {
			return List.of(new ParameterDefinition() {
				public Optional<ConceptDefinition<?>> asConceptDefinition() {
					return $parameter+asConceptDefinition;
				}
				public Class<?> javaClass() {
					return $parameterType~.class;
				}
			});
		}
	});
end

def type(parameter) type(entity) trigger(asConceptDefinition)
	Optional.of(datamart().$name+firstLowerCase~EntityDefinition)
end

def type(parameter) type(struct) trigger(asConceptDefinition)
	Optional.of(datamart().$name+firstLowerCase~StructDefinition)
end

def type(parameter) trigger(asConceptDefinition)
	Optional.empty()
end

def type(attribute) trigger(addDefinition)
	list.add(new AttributeDefinition() {
		public String name() {return "$name";}
		public Class<?> type() {return $type~.class;}
	});
end

def !type(abstract) type(entity) trigger(mountSwitchCase)
	case "$name+FirstUpperCase": new $package.mounters.$name+FirstUpperCase~Mounter(entities, entityListeners).mount(event); break;
end

def type(subclass) trigger(getAllStream)
	$name+Plural+firstLowerCase()
end

def type(abstract) trigger(getter)
	@Override
	public $package.entities.$name+FirstUpperCase $name+firstLowerCase(String id) {
		return id == null ? null : ($package.entities.$name+FirstUpperCase) entities.get(definition.$name+firstLowerCase~EntityDefinition, id);
	}

	@Override
	public Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return Stream.of(
			$subclass+getAllStream...[,$NL]
		).<$package.entities.$name+FirstUpperCase>flatMap(java.util.function.Function.identity());//.distinct();
	}
end

def !type(abstract) trigger(getter)
	@Override
	public $package.entities.$name+FirstUpperCase $name+firstLowerCase(String id) {
		return id == null ? null : entities.get(definition.$name+firstLowerCase~EntityDefinition, id);
	}

	@Override
	public Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return entities.stream(definition.$name+firstLowerCase~EntityDefinition);
	}
end

def trigger(getterSignature)
	$package.entities.$name+FirstUpperCase $name+firstLowerCase(String id);
	Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase();
	default List<$package.entities.$name+FirstUpperCase> $name+firstLowerCase~List() {return $name+Plural+firstLowerCase().collect(Collectors.toList());}
end
