def type(master & view)
	package $package;

	import java.util.Arrays;
    import java.util.List;
    import java.util.UUID;
    import java.util.stream.Stream;
    import java.util.stream.Collectors;
    import $package.entities.*;

	public interface MasterView {

		$entity+getterSignature...[$NL$NL]
	}
end

def type(master & interface)
	package $package;

	import java.util.Arrays;
	import java.util.Map;
	import java.util.HashMap;
	import java.util.List;
	import java.util.UUID;
	import java.util.concurrent.Future;
	import java.util.concurrent.CompletableFuture;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.messages.listeners.EntityListener;
	import io.intino.ness.master.messages.listeners.ErrorListener;
	import io.intino.ness.master.messages.Response;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.core.*;

	import $package.entities.*;

	public interface MasterTerminal extends MasterView {

		static MasterTerminal create() {
			return create(new MasterTerminal.Config());
		}

		static MasterTerminal create(MasterTerminal.Config config) {
			if(config.type() == Type.FullLoad) return new FullLoadMasterTerminal(config);
			if(config.type() == Type.LazyLoad) return new LazyLoadMasterTerminal(config);
			throw new IllegalArgumentException("Unknown MasterTerminal type " + config.type());
		}

		void start();
		void stop();

		<T extends Entity> Future<Response<T>> enable(String entityId);
		<T extends Entity> Future<Response<T>> disable(String entityId);
		<T extends Entity> Future<Response<T>> publish(Entity entity);

		MasterView disabled();

		MasterTerminal.Config config();

		io.intino.ness.master.serialization.MasterSerializer serializer();

		void addLifecycleListener(MasterLifecycleListener listener);

		void addErrorListener(ErrorListener listener);

		<T extends Entity> void addEntityListener(String type, EntityListener<T> listener);

		$entity+entityListener...[$NL$NL]

		@SuppressWarnings("unchecked")
		default <T extends Entity> T asEntity(TripletRecord record) {
			if(record == null) return null;
			switch(record.type()) {
				$entity+asEntitySwitchCase...[$NL]
				default: throw new IllegalArgumentException("Unknown entity type " + record.type());
			}
		}

		default ClientConfig getHazelcastConfig() {
			MasterTerminal.Config config = config();

			ClientConfig hzConfig = new ClientConfig();
			hzConfig.setInstanceName(config.clientName());
			hzConfig.setNetworkConfig(new ClientNetworkConfig().setAddresses(config.addresses()));
			hzConfig.properties().forEach(hzConfig::setProperty);

			if(config.connectionConfig() != null) {
				Config.ConnectionConfig connectionConfig = config.connectionConfig();
				hzConfig.getConnectionStrategyConfig().getConnectionRetryConfig()
                	.setInitialBackoffMillis(connectionConfig.initialBackoffMillis())
                    .setMaxBackoffMillis(connectionConfig.maxBackoffMillis())
                	.setClusterConnectTimeoutMillis(connectionConfig.clusterConnectTimeoutMillis())
                    .setMultiplier(connectionConfig.multiplier())
                    .setJitter(connectionConfig.)jitter();
			}

			return hzConfig;
		}

		enum Type {
			/**
			* <p>All records will be loaded into local-memory maps on start.</p>
			*/
    		FullLoad,

    		/**
    		* <p>Records will be loaded from the master backend on demand.</p>
    		*/
    		LazyLoad;

    		public static Type getDefault() {return FullLoad;}
    		public static Type byName(String name) {return Arrays.stream(values()).filter(e -> e.name().equalsIgnoreCase(name)).findFirst().orElse(null);}
    	}

    	enum EntityFilter {
    		OnlyEnabled, OnlyDisabled, All
    	}

    	final class Config {

    		private String clientName = "$package.MasterTerminal-" + UUID.randomUUID();
    		private List<String> addresses = List.of("localhost:5701");
    		private Type type = Type.getDefault();
    		private boolean allowWriting = false;
    		private boolean multithreadLoading = true;
    		private EntityFilter filter = EntityFilter.OnlyEnabled;
    		private boolean cacheDisabledView = true;
    		private ConnectionConfig connectionConfig;
    		private final Map<String, String> properties = new HashMap<>() {{
    			put("hazelcast.logging.type", "none");
    			put("master.log.initialization_complete", "true");
    		}};

    		public Config() {}

    		public Config(Config other) {
    			this.clientName = other.clientName;
    			this.addresses = other.addresses == null ? null : List.copyOf(other.addresses);
    			this.type = other.type;
    			this.allowWriting = other.allowWriting;
    			this.multithreadLoading = other.multithreadLoading;
    			this.filter = other.filter;
    			this.cacheDisabledView = other.cacheDisabledView;
    			this.properties.putAll(other.properties);
    		}

    		public String clientName() {
    			return clientName;
    		}

    		public Config clientName(String clientName) {
    			this.clientName = clientName;
    			return this;
    		}

    		public List<String> addresses() {
    			return addresses;
    		}

    		public Config addresses(List<String> addresses) {
    			this.addresses = addresses;
    			return this;
    		}

    		public Type type() {
    			return type;
    		}

    		public Config type(Type type) {
    			this.type = type;
    			return this;
    		}

    		public boolean allowWriting() {
    			return allowWriting;
    		}

    		public Config allowWriting(boolean allowWriting) {
    			this.allowWriting = allowWriting;
    			return this;
    		}

    		public boolean multithreadLoading() {
    			return multithreadLoading;
    		}

    		public Config multithreadLoading(boolean multithreadLoading) {
    			this.multithreadLoading = multithreadLoading;
    			return this;
    		}

    		public EntityFilter filter() {
    			return filter;
    		}

    		public Config filter(EntityFilter filter) {
    			this.filter = filter == null ? EntityFilter.OnlyEnabled : filter;
    			return this;
    		}

    		public boolean cacheDisabledView() {
    			return cacheDisabledView;
    		}

    		public Config cacheDisabledView(boolean cache) {
    			this.cacheDisabledView = cache;
    			return this;
    		}

			public ConnectionConfig connectionConfig() {
				return connectionConfig;
			}

			public Config connectionConfig(ConnectionConfig connectionConfig) {
				this.connectionConfig = connectionConfig;
				return this;
			}

    		public Map<String, String> properties() {
    			return properties;
    		}

    		public Config putProperty(String key, String value) {
    			this.properties.put(key, value);
    			return this;
    		}

    		public Config removeProperty(String key) {
    			this.properties.remove(key);
    			return this;
    		}

			public static class ConnectionConfig {

				private int initialBackoffMillis = 1000;
				private int maxBackoffMillis = 30000;
				private float multiplier = 1.05f;
				private int clusterConnectTimeoutMillis = - 1;
				private float jitter = 0;

				public int initialBackoffMillis() {
					return initialBackoffMillis;
				}

				public ConnectionConfig initialBackoffMillis(int initialBackoffMillis) {
					this.initialBackoffMillis = initialBackoffMillis;
					return this;
				}

				public int maxBackoffMillis() {
					return maxBackoffMillis;
				}

				public ConnectionConfig maxBackoffMillis(int maxBackoffMillis) {
					this.maxBackoffMillis = maxBackoffMillis;
					return this;
				}

				public float multiplier() {
					return multiplier;
				}

				public ConnectionConfig multiplier(float multiplier) {
					this.multiplier = multiplier;
					return this;
				}

				public int clusterConnectTimeoutMillis() {
					return clusterConnectTimeoutMillis;
				}

				public ConnectionConfig clusterConnectTimeoutMillis(int clusterConnectTimeoutMillis) {
					this.clusterConnectTimeoutMillis = clusterConnectTimeoutMillis;
					return this;
				}

				public float jitter() {
					return jitter;
				}

				public ConnectionConfig jitter(float jitter) {
					this.jitter = jitter;
					return this;
				}
			}
    	}
	}
end

def type(master & cached)
	package $package;

	import com.hazelcast.client.HazelcastClient;
	import com.hazelcast.client.config.ClientConfig;
	import com.hazelcast.client.config.ClientNetworkConfig;
	import com.hazelcast.core.HazelcastInstance;
	import com.hazelcast.map.IMap;
	import com.hazelcast.topic.Message;
	import com.hazelcast.topic.MessageListener;
	import io.intino.alexandria.logger.Logger;
	import io.intino.ness.master.core.*;
	import io.intino.ness.master.messages.*;
	import io.intino.ness.master.messages.listeners.EntityListener;
	import io.intino.ness.master.messages.listeners.EntityListener.Event;
	import io.intino.ness.master.messages.listeners.ErrorListener;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.model.Triplet;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.serialization.MasterSerializer;
	import io.intino.ness.master.serialization.MasterSerializers;
	import io.intino.ness.master.core.*;

	import java.time.Instant;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import java.util.Map;
	import java.util.concurrent.*;
	import java.util.concurrent.atomic.AtomicBoolean;
	import java.util.logging.ConsoleHandler;
	import java.util.logging.Handler;
	import java.util.logging.Level;
	import java.util.logging.LogManager;
	import java.util.stream.Stream;

	import static io.intino.ness.master.core.Master.MASTER_MAP_NAME;
	import static io.intino.ness.master.core.Master.METADATA_MAP_NAME;
	import static io.intino.ness.master.messages.MasterTopics.*;
	import static java.util.Objects.requireNonNull;

	import $package.entities.*;

	@SuppressWarnings({"rawtypes", "unchecked"})
	public class FullLoadMasterTerminal implements MasterTerminal {

    	$entity+map...[$NL]

		private final AtomicBoolean initialized = new AtomicBoolean(false);
    	private final MasterTerminal.Config config;
		protected HazelcastInstance hazelcast;
		private final Map<String, List<EntityListener>> entityListeners = new ConcurrentHashMap<>();
		private final List<ErrorListener> errorListeners = Collections.synchronizedList(new ArrayList<>());
		private final Map<String, CompletableFuture> futures = new ConcurrentHashMap<>();
		private DisabledView disabledView;

    	public FullLoadMasterTerminal(MasterTerminal.Config config) {
    		this(config, null);
    	}

    	public FullLoadMasterTerminal(MasterTerminal.Config config, HazelcastInstance hazelcast) {
        	this.config = requireNonNull(config);
        	this.hazelcast = hazelcast;
       	}

		@Override
		public void start() {
			if(!initialized.compareAndSet(false, true)) return;
			configureLogger();
			initHazelcastClient();
			loadData();
			initListeners();
			if("true".equals(config.properties().getOrDefault("master.log.initialization_complete", "true")))
				Logger.info("MasterTerminal " + config.clientName() + " initialized successfully. (" + getClass().getSimpleName() + ")");
		}

		@Override
    	public void stop() {
    		hazelcast.shutdown();
    	}

    	@Override
    	public void addLifecycleListener(MasterLifecycleListener listener) {
    		if(listener == null) throw new NullPointerException("MasterLifecycleListener cannot be null");
    		hazelcast.getLifecycleService().addLifecycleListener(e -> {
    			listener.onChanged(new MasterLifecycleEvent(toLifecycleState(e.getState())));
    		});
    	}

    	private static MasterLifecycleEvent.State toLifecycleState(LifecycleState state) {
    		return Arrays.stream(MasterLifecycleEvent.State.values()).filter(s -> s.name().equalsIgnoreCase(state.name())).findFirst().orElse(null);
    	}

		@Override
		public void addErrorListener(ErrorListener listener) {
			if(listener == null) throw new NullPointerException("ErrorListener cannot be null");
			errorListeners.add(listener);
		}

		@Override
    	public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
    		if(type == null) throw new NullPointerException("Type cannot be null");
    		if(listener == null) throw new NullPointerException("EntryListener cannot be null");
    		entityListeners.computeIfAbsent(type, k -> new ArrayList<>()).add(listener);
    	}

		@Override
    	public MasterSerializer serializer() {
        	IMap<String, String> metadata = hazelcast.getMap(METADATA_MAP_NAME);
        	return MasterSerializers.get(metadata.get("serializer"));
        }

    	@Override
    	public MasterTerminal.Config config() {
    		return new MasterTerminal.Config(config);
    	}

    	$entity+getter...[$NL$NL]

    	@Override
    	public <T extends Entity> Future<Response<T>> enable(String id) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
            if(id == null) throw new NullPointerException("Entity id cannot be null");
            UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Enable, id);
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
            MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
            return future;
    	}

      	@Override
      	public <T extends Entity> Future<Response<T>> disable(String id) {
      		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
            if(id == null) throw new NullPointerException("Entity id cannot be null");
            UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Disable, id);
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
            MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
            return future;
      	}

		@Override
    	public <T extends Entity> Future<Response<T>> publish(Entity entity) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
			if(entity == null) throw new NullPointerException("Entity cannot be null");
			UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Publish, serializer().serialize(entity.asTripletRecord()));
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
			MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
			return future;
    	}

    	@Override
    	public synchronized MasterView disabled() {
      		if(config.filter() == MasterTerminal.EntityFilter.OnlyDisabled) return this;
    		if(!config.cacheDisabledView()) {
    			DisabledView view = new DisabledView(config, hazelcast);
    			view.start();
    			return view;
    		}
    		if(disabledView == null) {
    			disabledView = new DisabledView(config, hazelcast);
    			disabledView.start();
    		}
    		return disabledView;
    	}

    	private UpdateMasterMessage createMessage(UpdateMasterMessage.Action action, String value) {
    		return new UpdateMasterMessage(config.clientName(), action, value);
    	}

    	private boolean isIgnored(TripletRecord record) {
    		if(config.filter() == MasterTerminal.EntityFilter.All) return false;
    		return isEnabled(record)
    			? config.filter() == MasterTerminal.EntityFilter.OnlyDisabled
    			: config.filter() == MasterTerminal.EntityFilter.OnlyEnabled;
    	}

    	private boolean isEnabled(TripletRecord record) {
    		String enabledValue = record.getValue("enabled");
            return enabledValue == null || "true".equalsIgnoreCase(enabledValue);
    	}

    	protected void add(TripletRecord record) {
    		if(isIgnored(record)) return;
    		switch(record.type()) {
    			$entity+adder...[$NL]
    		}
    	}

    	protected void remove(String id) {
    		switch(Triplet.typeOf(id)) {
    			$entity+remover...[$NL]
    		}
    	}

    	$entity+add...[$NL$NL]

    	$entity+remove...[$NL$NL]

    	private void initHazelcastClient() {
    		if(hazelcast != null) return;

			ClientConfig config = new ClientConfig();
			config.setInstanceName(this.config.clientName());
			config.setNetworkConfig(new ClientNetworkConfig().setAddresses(this.config.addresses()));
			this.config.properties().forEach(config::setProperty);

			hazelcast = HazelcastClient.newHazelcastClient(config);
    	}

		protected void initListeners() {
			hazelcast.getTopic(MASTER_LISTENER_TOPIC).addMessageListener(new ListenerTopicMessageListener());
			hazelcast.getTopic(MASTER_ERROR_TOPIC).addMessageListener(new ErrorTopicMessageListener());
		}

		private void loadData() {
			IMap<String, String> master = hazelcast.getMap(MASTER_MAP_NAME);
			MasterSerializer serializer = serializer();

			Logger.debug("Loading data from master (serializer=" + serializer.name() + ")");
			long start = System.currentTimeMillis();

			if(config.multithreadLoading())
				loadDataMultiThread(master, serializer);
			else
				loadDataSingleThread(master, serializer);

			long time = System.currentTimeMillis() - start;
			Logger.debug("Data from master loaded in " + time + " ms");
		}

		private void loadDataSingleThread(IMap<String, String> master, MasterSerializer serializer) {
			master.forEach((id, serializedRecord) -> add(serializer.deserialize(serializedRecord)));
		}

		private void loadDataMultiThread(IMap<String, String> master, MasterSerializer serializer) {
			try {
				ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() - 1);

				master.forEach((id, serializedRecord) -> threadPool.submit(() -> add(serializer.deserialize(serializedRecord))));

				threadPool.shutdown();
				threadPool.awaitTermination(1, TimeUnit.HOURS);
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

    	private static void configureLogger() {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger("");
			rootLogger.setLevel(Level.WARNING);
			for (Handler h : rootLogger.getHandlers()) rootLogger.removeHandler(h);
			final ConsoleHandler handler = new ConsoleHandler();
			handler.setLevel(Level.WARNING);
			handler.setFormatter(new io.intino.alexandria.logger.Formatter());
			rootLogger.setUseParentHandlers(false);
			rootLogger.addHandler(handler);
		}

		private class ErrorTopicMessageListener implements MessageListener<Object> {

			@Override
			public void onMessage(Message<Object> rawMessage) {
				ErrorMasterMessage message = MasterMessageSerializer.deserialize(rawMessage.getMessageObject(), ErrorMasterMessage.class);
            	notifyErrorListeners(new MasterError(message.ts(), message.error()));
			}

			protected void notifyErrorListeners(ErrorListener.Error error) {
				if(error.messageId() != null) {
					CompletableFuture<Response<?>> future = futures.remove(error.messageId());
					if(future != null) future.complete(Response.ofFailure(error));
				}

				errorListeners.forEach(listener -> listener.notify(error));
			}

			protected class MasterError implements ErrorListener.Error {

				private final Instant ts;
				private final MasterMessageException error;

				private MasterError(Instant ts, MasterMessageException error) {
					this.ts = ts;
					this.error = error;
				}

				@Override
				public Instant ts() {
					return ts;
				}

				@Override
				public MasterMessageException cause() {
					return error;
				}
			}
		}

		private class ListenerTopicMessageListener implements MessageListener<Object> {

			@Override
			public void onMessage(Message<Object> rawMessage) {
				ListenerMasterMessage message = MasterMessageSerializer.deserialize(String.valueOf(rawMessage.getMessageObject()), ListenerMasterMessage.class);
				TripletRecord record = serializer().tryDeserialize(message.record()).orElse(null);
				Event<?> event = new MasterEntityEvent<>(
					message.serverName(), message.clientName(),	asEventType(message.action()),
					message.recordId(), asEntity(record), message.record(),
					message.ts(), message.updateMessageId());
				process(event, record);
				notifyEntityListeners(event);
			}

			protected void process(Event<?> event, TripletRecord record) {
				switch(event.type()) {
					case Create:
					case Update:
					case Enable:
						add(record);
						break;
					case Disable:
					case Remove:
						remove(record.id());
						break;
				}
			}

			private Event.Type asEventType(ListenerMasterMessage.Action action) {
				switch(action) {
					case Created: return Event.Type.Create;
					case Updated: return Event.Type.Update;
					case Enabled: return Event.Type.Enable;
					case Disabled: return Event.Type.Disable;
					case Removed: return Event.Type.Remove;
					case None: return Event.Type.None;
					default: throw new IllegalArgumentException("Unknown listener action " + action);
				}
			}

			@SuppressWarnings("all")
			protected void notifyEntityListeners(Event<?> event) {
				CompletableFuture<Response<?>> future = futures.remove(event.messageId());
				if(future != null) future.complete(Response.ofSuccessful(event));

				List<EntityListener> listeners = entityListeners.get(event.entityId().type());
				if(listeners != null) listeners.forEach(listener -> listener.notify(event));
			}
		}

		static class DisabledView extends FullLoadMasterTerminal {

			public DisabledView(Config config, HazelcastInstance hazelcast) {
				super(
					new Config(config)
						.allowWriting(false)
						.filter(EntityFilter.OnlyDisabled)
						.putProperty("master.log.initialization_complete", "false"),
					hazelcast);
			}

			@Override
			public void addErrorListener(ErrorListener listener) {
				throw new UnsupportedOperationException();
			}

			@Override
			public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
				throw new UnsupportedOperationException();
			}

			@Override
			public void stop() {
				throw new UnsupportedOperationException();
			}

			@Override
			public MasterView disabled() {
				return this;
			}

			@Override
			protected void initListeners() {
				hazelcast.getTopic(MASTER_LISTENER_TOPIC).addMessageListener(new DisabledListenerTopicMessageListener());
			}

			private class DisabledListenerTopicMessageListener extends ListenerTopicMessageListener {

				protected void process(Event<?> event, TripletRecord record) {
					switch(event.type()) {
						case Create:
						case Update:
						case Enable:
							remove(record.id());
							break;
						case Disable:
						case Remove:
							add(record);
							break;
					}
				}

				protected void notifyEntityListeners(Event<?> event) {}
			}
		}

		public static class MasterEntityEvent<T extends Entity> implements Event<T> {

			private final String serverName;
			private final String clientName;
			private final Type type;
			private final Entity.Id entityId;
			private final T entity;
			private final String value;
			private final Instant ts;
			private final String messageId;

			private MasterEntityEvent(String serverName, String clientName, Type type, String entityId, T entity, String value, Instant ts, String messageId) {
				this.serverName = serverName;
				this.clientName = clientName;
				this.type = type;
				this.entityId = new Entity.Id(entityId);
				this.entity = entity;
				this.value = value;
				this.ts = ts;
				this.messageId = messageId;
			}

			@Override
			public String serverName() {
				return serverName;
			}

			@Override
			public String clientName() {
				return clientName;
			}

			@Override
			public Type type() {
				return type;
			}

			@Override
			public Entity.Id entityId() {
				return entityId;
			}

			@Override
			public T entity() {
				return entity;
			}

			@Override
			public String value() {
				return value;
			}

			@Override
			public Instant ts() {
				return ts;
			}

			@Override
			public String messageId() {
				return messageId;
			}
		}
    }
end


def type(master & lazy)
	package $package;

	import com.hazelcast.client.HazelcastClient;
	import com.hazelcast.client.config.ClientConfig;
	import com.hazelcast.client.config.ClientNetworkConfig;
	import com.hazelcast.core.HazelcastInstance;
	import com.hazelcast.map.IMap;
	import com.hazelcast.topic.Message;
	import com.hazelcast.topic.MessageListener;
	import io.intino.alexandria.logger.Logger;
	import io.intino.ness.master.messages.*;
	import io.intino.ness.master.messages.listeners.EntityListener;
	import io.intino.ness.master.messages.listeners.EntityListener.Event;
	import io.intino.ness.master.messages.listeners.ErrorListener;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.model.Triplet;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.serialization.MasterSerializer;
	import io.intino.ness.master.serialization.MasterSerializers;

	import java.time.Instant;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import java.util.Map;
	import java.util.function.BiFunction;
	import java.util.concurrent.*;
	import java.util.concurrent.atomic.AtomicBoolean;
	import java.util.logging.ConsoleHandler;
	import java.util.logging.Handler;
	import java.util.logging.Level;
	import java.util.logging.LogManager;
	import java.util.stream.Stream;

	import static io.intino.ness.master.core.Master.MASTER_MAP_NAME;
	import static io.intino.ness.master.core.Master.METADATA_MAP_NAME;
	import static io.intino.ness.master.messages.MasterTopics.*;
	import static java.util.Objects.requireNonNull;

	import $package.entities.*;

	@SuppressWarnings({"rawtypes", "unchecked"})
	public class LazyLoadMasterTerminal implements MasterTerminal {

		private final AtomicBoolean initialized = new AtomicBoolean(false);
    	private final MasterTerminal.Config config;
		protected HazelcastInstance hazelcast;
		private IMap<String, String> masterMap;
		private MasterSerializer serializer;
		private final Map<String, List<EntityListener>> entityListeners = new ConcurrentHashMap<>();
		private final List<ErrorListener> errorListeners = Collections.synchronizedList(new ArrayList<>());
		private final Map<String, CompletableFuture> futures = new ConcurrentHashMap<>();
		private DisabledView disabledView;

    	public LazyLoadMasterTerminal(MasterTerminal.Config config) {
    		this(config, null);
    	}

    	public LazyLoadMasterTerminal(MasterTerminal.Config config, HazelcastInstance hazelcast) {
    		this.config = requireNonNull(config);
    		this.hazelcast = hazelcast;
    	}

		@Override
		public void start() {
			if(!initialized.compareAndSet(false, true)) return;
			configureLogger();
			initHazelcastClient();
			if("true".equals(config.properties().getOrDefault("master.log.initialization_complete", "true")))
				Logger.info("MasterTerminal " + config.clientName() + " initialized successfully. (" + getClass().getSimpleName() + ")");
		}

		@Override
    	public void stop() {
    		hazelcast.shutdown();
    	}

    	@Override
    	public void addLifecycleListener(MasterLifecycleListener listener) {
    		if(listener == null) throw new NullPointerException("MasterLifecycleListener cannot be null");
    		hazelcast.getLifecycleService().addLifecycleListener(e -> {
    			listener.onChanged(new MasterLifecycleEvent(toLifecycleState(e.getState())));
    		});
    	}

    	private static MasterLifecycleEvent.State toLifecycleState(LifecycleState state) {
    		return Arrays.stream(MasterLifecycleEvent.State.values()).filter(s -> s.name().equalsIgnoreCase(state.name())).findFirst().orElse(null);
    	}

		@Override
		public void addErrorListener(ErrorListener listener) {
			if(listener == null) throw new NullPointerException("ErrorListener cannot be null");
			errorListeners.add(listener);
		}

		@Override
    	public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
    		if(type == null) throw new NullPointerException("Type cannot be null");
    		if(listener == null) throw new NullPointerException("EntryListener cannot be null");
    		entityListeners.computeIfAbsent(type, k -> new ArrayList<>()).add(listener);
    	}

    	@Override
        public MasterSerializer serializer() {
        	return serializer;
        }

    	@Override
    	public MasterTerminal.Config config() {
    		return new MasterTerminal.Config(config);
    	}

    	@Override
    	public <T extends Entity> Future<Response<T>> enable(String id) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
            if(id == null) throw new NullPointerException("Entity id cannot be null");
            UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Enable, id);
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
            MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
            return future;
    	}

      	@Override
      	public <T extends Entity> Future<Response<T>> disable(String id) {
      		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
            if(id == null) throw new NullPointerException("Entity id cannot be null");
            UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Disable, id);
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
            MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
            return future;
      	}

		@Override
    	public <T extends Entity> Future<Response<T>> publish(Entity entity) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client is configured as read only");
			if(entity == null) throw new NullPointerException("Entity cannot be null");
			UpdateMasterMessage message = createMessage(UpdateMasterMessage.Action.Publish, serializer().serialize(entity.asTripletRecord()));
            CompletableFuture<Response<T>> future = new CompletableFuture<>();
            futures.put(message.id(), future);
			MasterMessagePublisher.publishMessage(hazelcast, MASTER_UPDATE_TOPIC, message);
			return future;
    	}

    	@Override
    	public synchronized MasterView disabled() {
      		if(config.filter() == MasterTerminal.EntityFilter.OnlyDisabled) return this;
    		if(!config.cacheDisabledView()) {
    			DisabledView view = new DisabledView(config, hazelcast);
    			view.start();
    			return view;
    		}
    		if(disabledView == null) {
    			disabledView = new DisabledView(config, hazelcast);
    			disabledView.start();
    		}
    		return disabledView;
    	}

    	private UpdateMasterMessage createMessage(UpdateMasterMessage.Action action, String value) {
    		return new UpdateMasterMessage(config.clientName(), action, value);
    	}

    	$entity+getter...[$NL$NL]

    	private TripletRecord getRecord(String id) {
        	String serializedRecord = masterMap.get(id);
        	if(serializedRecord == null || isIgnored(serializedRecord)) return null;
        	return serializer.deserialize(serializedRecord);
        }

   		private <T extends Entity> T entity(BiFunction<String, MasterTerminal, T> constructor, String id, TripletRecord record) {
   			T entity = constructor.apply(id, this);
   			record.triplets().forEach(entity::add);
   			return entity;
   		}

		private boolean accepts(String serializedRecord) {
			return !isIgnored(serializedRecord);
		}

		private boolean isIgnored(String serializedRecord) {
    		if(config.filter() == MasterTerminal.EntityFilter.All) return false;
    		return isEnabled(serializer.deserialize(serializedRecord))
    			? config.filter() == MasterTerminal.EntityFilter.OnlyDisabled
    			: config.filter() == MasterTerminal.EntityFilter.OnlyEnabled;
   		}

    	private boolean isEnabled(TripletRecord record) {
    		String enabledValue = record.getValue("enabled");
            return enabledValue == null || "true".equalsIgnoreCase(enabledValue);
    	}

    	private void initHazelcastClient() {
    		ClientConfig config = new ClientConfig();
        	config.setInstanceName(this.config.clientName());
        	config.setNetworkConfig(new ClientNetworkConfig().setAddresses(this.config.addresses()));

        	hazelcast = HazelcastClient.newHazelcastClient(config);

        	masterMap = hazelcast.getMap(MASTER_MAP_NAME);
        	IMap<String, String> metadata = hazelcast.getMap(METADATA_MAP_NAME);
        	serializer = MasterSerializers.get(metadata.get("serializer"));

        	initListeners();
    	}

		protected void initListeners() {
			hazelcast.getTopic(MASTER_LISTENER_TOPIC).addMessageListener(new ListenerTopicMessageListener());
			hazelcast.getTopic(MASTER_ERROR_TOPIC).addMessageListener(new ErrorTopicMessageListener());
		}

    	private static void configureLogger() {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger("");
			rootLogger.setLevel(Level.WARNING);
			for (Handler h : rootLogger.getHandlers()) rootLogger.removeHandler(h);
			final ConsoleHandler handler = new ConsoleHandler();
			handler.setLevel(Level.WARNING);
			handler.setFormatter(new io.intino.alexandria.logger.Formatter());
			rootLogger.setUseParentHandlers(false);
			rootLogger.addHandler(handler);
		}

		private class ErrorTopicMessageListener implements MessageListener<Object> {

			@Override
			public void onMessage(Message<Object> rawMessage) {
				ErrorMasterMessage message = MasterMessageSerializer.deserialize(String.valueOf(rawMessage.getMessageObject()), ErrorMasterMessage.class);
            	notifyErrorListeners(new MasterError(message.ts(), message.error()));
			}

			protected void notifyErrorListeners(ErrorListener.Error error) {
				if(error.messageId() != null) {
					CompletableFuture<Response<?>> future = futures.remove(error.messageId());
					if(future != null) future.complete(Response.ofFailure(error));
				}

				errorListeners.forEach(listener -> listener.notify(error));
			}

			protected class MasterError implements ErrorListener.Error {

				private final Instant ts;
				private final MasterMessageException error;

				private MasterError(Instant ts, MasterMessageException error) {
					this.ts = ts;
					this.error = error;
				}

				@Override
				public Instant ts() {
					return ts;
				}

				@Override
				public MasterMessageException cause() {
					return error;
				}
			}
		}


		private class ListenerTopicMessageListener implements MessageListener<Object> {

			@Override
			public void onMessage(Message<Object> rawMessage) {
				ListenerMasterMessage message = MasterMessageSerializer.deserialize(String.valueOf(rawMessage.getMessageObject()), ListenerMasterMessage.class);
				TripletRecord record = serializer().tryDeserialize(message.record()).orElse(null);
				Event<?> event = new MasterEntityEvent<>(
					message.serverName(), message.clientName(),	asEventType(message.action()),
					message.recordId(), asEntity(record), message.record(),
					message.ts(), message.updateMessageId());
				notifyEntityListeners(event);
			}

			private Event.Type asEventType(ListenerMasterMessage.Action action) {
				switch(action) {
					case Created: return Event.Type.Create;
					case Updated: return Event.Type.Update;
					case Enabled: return Event.Type.Enable;
					case Disabled: return Event.Type.Disable;
					case Removed: return Event.Type.Remove;
					case None: return Event.Type.None;
					default: throw new IllegalArgumentException("Unknown listener action " + action);
				}
			}

			@SuppressWarnings("all")
			protected void notifyEntityListeners(Event<?> event) {
				CompletableFuture<Response<?>> future = futures.remove(event.messageId());
				if(future != null) future.complete(Response.ofSuccessful(event));

				List<EntityListener> listeners = entityListeners.get(event.entityId().type());
				if(listeners != null) listeners.forEach(listener -> listener.notify(event));
			}
		}

		static class DisabledView extends LazyLoadMasterTerminal {

			public DisabledView(Config config, HazelcastInstance hazelcast) {
				super(
					new Config(config)
						.allowWriting(false)
						.filter(EntityFilter.OnlyDisabled)
						.putProperty("master.log.initialization_complete", "false"),
					hazelcast);
			}

			@Override
			public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
				throw new UnsupportedOperationException();
			}

			@Override
			public void stop() {
				throw new UnsupportedOperationException();
			}

			@Override
			public MasterView disabled() {
				return this;
			}

			@Override
			protected void initListeners() {
				hazelcast.getTopic(MASTER_LISTENER_TOPIC).addMessageListener(new DisabledListenerTopicMessageListener());
			}

			private class DisabledListenerTopicMessageListener extends ListenerTopicMessageListener {
				protected void notifyEntityListeners(Event<?> event) {}
			}
		}

		public static class MasterEntityEvent<T extends Entity> implements Event<T> {

			private final String serverName;
			private final String clientName;
			private final Type type;
			private final Entity.Id entityId;
			private final T entity;
			private final String value;
			private final Instant ts;
			private final String messageId;

			private MasterEntityEvent(String serverName, String clientName, Type type, String entityId, T entity, String value, Instant ts, String messageId) {
				this.serverName = serverName;
				this.clientName = clientName;
				this.type = type;
				this.entityId = new Entity.Id(entityId);
				this.entity = entity;
				this.value = value;
				this.ts = ts;
				this.messageId = messageId;
			}

			@Override
			public String serverName() {
				return serverName;
			}

			@Override
			public String clientName() {
				return clientName;
			}

			@Override
			public Type type() {
				return type;
			}

			@Override
			public Entity.Id entityId() {
				return entityId;
			}

			@Override
			public T entity() {
				return entity;
			}

			@Override
			public String value() {
				return value;
			}

			@Override
			public Instant ts() {
				return ts;
			}

			@Override
			public String messageId() {
				return messageId;
			}
		}
    }
end


def !type(abstract) trigger(remover)
	case "$name+lowerCase": removeFrom$name+FirstUpperCase(id); break;
end

def !type(abstract) trigger(adder)
	case "$name+lowerCase": addTo$name+FirstUpperCase(record); break;
end

def !type(abstract) trigger(map)
	private final Map<String, $name+FirstUpperCase> $name+FirstLowerCase~Map = new ConcurrentHashMap<>();
end

def !type(abstract) trigger(add)
	private void addTo$name+FirstUpperCase(TripletRecord record) {
		$name+FirstUpperCase entity = new $name+FirstUpperCase(record.id(), this);
    	record.triplets().forEach(entity::add);
    	$name+firstLowerCase~Map.put(record.id(), entity);
    }
end

def !type(abstract) trigger(remove)
	private void removeFrom$name+FirstUpperCase(String id) {
		$name+firstLowerCase~Map.remove(id);
	}
end

def type(subclass) trigger(getById)
	case "$name+lowerCase": return $name+firstLowerCase(id);
end

def type(subclass) trigger(getAllStream)
	$name+Plural+firstLowerCase()
end

def type(abstract) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
    	switch(Triplet.typeOf(id)) {
    		$subclass+getById...[$NL]
    	}
    	return null;
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return Stream.of(
			$subclass+getAllStream...[,$NL]
		).flatMap(java.util.function.Function.identity());
	}
end

def !type(abstract) type(cached) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
		return $name+firstLowerCase~Map.get(id);
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return $name+firstLowerCase~Map.values().stream();
	}
end

def !type(abstract) type(lazy) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
		TripletRecord record = getRecord(id);
    	return record != null ? entity($name+FirstUpperCase::new, id, record) : null;
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return masterMap.entrySet().stream()
				.filter(e -> e.getKey().endsWith(":$name+firstLowerCase"))
				.filter(e -> accepts(e.getValue()))
				.map(e -> entity($name+FirstUpperCase::new, e.getKey(), serializer.deserialize(e.getValue())));
	}
end

def trigger(getterSignature)
	$name+FirstUpperCase $name+firstLowerCase(String id);
	Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase();
	default List<$name+FirstUpperCase> $name+firstLowerCase~List() {return $name+Plural+firstLowerCase().collect(Collectors.toList());}
end

def trigger(entityListener)
	default void add$name+FirstUpperCase~EntityListener(EntityListener<$name+FirstUpperCase> listener) {
		addEntityListener("$name+firstLowerCase", listener);
	}
end

def type(entity) !type(abstract) trigger(asEntitySwitchCase)
	case "$name+firstLowerCase": return (T) new $name+FirstUpperCase(record, this);
end