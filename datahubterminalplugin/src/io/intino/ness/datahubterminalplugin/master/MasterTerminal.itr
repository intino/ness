def type(master & interface)
	package $package;

	import java.util.Arrays;
	import java.util.List;
	import java.util.UUID;
	import java.util.stream.Stream;
	import java.util.stream.Collectors;
	import $package.entities.*;
	import io.intino.ness.master.model.Triplet;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.data.EntityListener;
	import io.intino.ness.master.model.Entity;

	public interface MasterTerminal {

		static MasterTerminal create() {
			return create(new MasterTerminal.Config());
		}

		static MasterTerminal create(MasterTerminal.Config config) {
			if(config.type() == Type.FullLoad) return new FullLoadMasterTerminal(config);
			if(config.type() == Type.LazyLoad) return new LazyLoadMasterTerminal(config);
			throw new IllegalArgumentException("Unknown MasterTerminal type " + config.type());
		}

		void start();
		void stop();

		void publish(Entity entity);

		MasterTerminal.Config config();

		io.intino.ness.master.serialization.MasterSerializer serializer();

		<T extends Entity> void addEntityListener(String type, EntityListener<T> listener);

		$entity+entityListener...[$NL$NL]

		$entity+getterSignature...[$NL$NL]

		@SuppressWarnings("unchecked")
		default <T extends Entity> T asEntity(TripletRecord record) {
			switch(record.type()) {
				$entity+asEntitySwitchCase...[$NL]
				default: throw new IllegalArgumentException("Unknown entity type " + record.type());
			}
		}

		enum Type {
			/**
			* <p>All records will be loaded into local-memory maps on start.</p>
			*/
    		FullLoad,

    		/**
    		* <p>Records will be loaded from the master backend on demand.</p>
    		*/
    		LazyLoad;

    		public static Type getDefault() {return FullLoad;}
    		public static Type byName(String name) {return Arrays.stream(values()).filter(e -> e.name().equalsIgnoreCase(name)).findFirst().orElse(null);}
    	}

    	final class Config {
    		private String instanceName = "$package.MasterTerminal-" + UUID.randomUUID();
    		private List<String> addresses = List.of("localhost:5701");
    		private Type type = Type.getDefault();
    		private boolean allowWriting = false;
    		private boolean multithreadLoading = true;

    		public Config() {}

    		public Config(Config other) {
    			this.instanceName = other.instanceName;
    			this.addresses = other.addresses == null ? null : List.copyOf(other.addresses);
    			this.type = other.type;
    			this.allowWriting = other.allowWriting;
    			this.multithreadLoading = other.multithreadLoading;
    		}

    		public String instanceName() {
    			return instanceName;
    		}

    		public Config instanceName(String instanceName) {
    			this.instanceName = instanceName;
    			return this;
    		}

    		public List<String> addresses() {
    			return addresses;
    		}

    		public Config addresses(List<String> addresses) {
    			this.addresses = addresses;
    			return this;
    		}

    		public Type type() {
    			return type;
    		}

    		public Config type(Type type) {
    			this.type = type;
    			return this;
    		}

    		public boolean allowWriting() {
    			return allowWriting;
    		}

    		public Config allowWriting(boolean allowWriting) {
    			this.allowWriting = allowWriting;
    			return this;
    		}

    		public boolean multithreadLoading() {
    			return multithreadLoading;
    		}

    		public Config multithreadLoading(boolean multithreadLoading) {
    			this.multithreadLoading = multithreadLoading;
    			return this;
    		}
    	}
	}
end

def type(master & cached)
	package $package;

	import com.hazelcast.client.HazelcastClient;
	import com.hazelcast.client.config.ClientConfig;
	import com.hazelcast.client.config.ClientNetworkConfig;
	import com.hazelcast.core.EntryAdapter;
	import com.hazelcast.core.EntryEvent;
	import com.hazelcast.core.HazelcastInstance;
	import com.hazelcast.map.IMap;
	import io.intino.alexandria.logger.Logger;
	import io.intino.ness.master.data.EntityListener;
	import io.intino.ness.master.data.EntityListener.Event;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.model.Triplet;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.serialization.MasterSerializer;
	import io.intino.ness.master.serialization.MasterSerializers;
	import $package.entities.*;

	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import java.util.concurrent.ConcurrentHashMap;
	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	import java.util.concurrent.TimeUnit;
	import java.util.logging.ConsoleHandler;
	import java.util.logging.Handler;
	import java.util.logging.Level;
	import java.util.logging.LogManager;
	import java.util.stream.Stream;

	import static io.intino.ness.master.core.Master.*;
	import static java.util.Objects.requireNonNull;

	public class FullLoadMasterTerminal implements MasterTerminal {

    	$entity+map...[$NL]

    	private final MasterTerminal.Config config;
		private HazelcastInstance hazelcast;
		@SuppressWarnings("rawtypes")
		private final Map<String, List<EntityListener>> entityListeners = new HashMap<>();

    	public FullLoadMasterTerminal(MasterTerminal.Config config) {
    		this.config = requireNonNull(config);
    	}

		@Override
		public void start() {
			configureLogger();
			initHazelcastClient();
			loadData();
			initListeners();
		}

		@Override
    	public void stop() {
    		hazelcast.shutdown();
    	}

		@Override
    	public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
    		if(type == null) throw new NullPointerException("Type cannot be null");
    		if(listener == null) throw new NullPointerException("EntryListener cannot be null");
    		entityListeners.computeIfAbsent(type, k -> new ArrayList<>()).add(listener);
    	}

		@Override
    	public MasterSerializer serializer() {
        	IMap<String, String> metadata = hazelcast.getMap(METADATA_MAP_NAME);
        	return MasterSerializers.get(metadata.get("serializer"));
        }

    	@Override
    	public MasterTerminal.Config config() {
    		return new MasterTerminal.Config(config);
    	}

    	$entity+getter...[$NL$NL]

		@Override
    	public void publish(Entity entity) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client cannot publish because it is configured as read only");
			if(entity == null) throw new NullPointerException("Entity cannot be null");
			hazelcast.getTopic(REQUESTS_TOPIC).publish(config.instanceName() + MESSAGE_SEPARATOR + serializer().serialize(entity.asTripletRecord()));
    	}

    	private void add(TripletRecord record) {
    		String enabledValue = record.getValue("enabled");
    		if(enabledValue != null && !"true".equalsIgnoreCase(enabledValue)) return;

    		switch(record.type()) {
    			$entity+adder...[$NL]
    		}
    	}

    	private void remove(String id) {
    		switch(Triplet.typeOf(id)) {
    			$entity+remover...[$NL]
    		}
    	}

    	$entity+add...[$NL$NL]

    	$entity+remove...[$NL$NL]

    	private void initHazelcastClient() {
			ClientConfig config = new ClientConfig();
			config.setInstanceName(this.config.instanceName());
			config.setNetworkConfig(new ClientNetworkConfig().setAddresses(this.config.addresses()));
			hazelcast = HazelcastClient.newHazelcastClient(config);
    	}

		private void initListeners() {
			hazelcast.getMap(MASTER_MAP_NAME).addEntryListener(new BaseEntryListener(), true);
		}

		private void loadData() {
			IMap<String, String> master = hazelcast.getMap(MASTER_MAP_NAME);
			MasterSerializer serializer = serializer();

			Logger.debug("Loading data from master (serializer=" + serializer.name() + ")");
			long start = System.currentTimeMillis();

			if(config.multithreadLoading())
				loadDataMultiThread(master, serializer);
			else
				loadDataSingleThread(master, serializer);

			long time = System.currentTimeMillis() - start;
			Logger.info("Data from master loaded in " + time + " ms");
		}

		private void loadDataSingleThread(IMap<String, String> master, MasterSerializer serializer) {
			master.forEach((id, serializedRecord) -> add(serializer.deserialize(serializedRecord)));
		}

		private void loadDataMultiThread(IMap<String, String> master, MasterSerializer serializer) {
			try {
				ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() - 1);

				master.forEach((id, serializedRecord) -> threadPool.submit(() -> add(serializer.deserialize(serializedRecord))));

				threadPool.shutdown();
				threadPool.awaitTermination(1, TimeUnit.HOURS);
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

    	private static void configureLogger() {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger("");
			rootLogger.setLevel(Level.WARNING);
			for (Handler h : rootLogger.getHandlers()) rootLogger.removeHandler(h);
			final ConsoleHandler handler = new ConsoleHandler();
			handler.setLevel(Level.WARNING);
			handler.setFormatter(new io.intino.alexandria.logger.Formatter());
			rootLogger.setUseParentHandlers(false);
			rootLogger.addHandler(handler);
		}

    	public class BaseEntryListener extends EntryAdapter<String, String> {

			@Override
			public void entryAdded(EntryEvent<String, String> event) {
				addOrUpdateRecord(event.getKey(), event.getValue());
				notifyEntityListeners(event, Event.Type.Create);
			}

			@Override
			public void entryUpdated(EntryEvent<String, String> event) {
				addOrUpdateRecord(event.getKey(), event.getValue());
				notifyEntityListeners(event, Event.Type.Update);
			}

			@Override
			public void entryRemoved(EntryEvent<String, String> event) {
				remove(event.getKey());
				notifyEntityListeners(event, Event.Type.Remove);
			}

			@Override
			public void entryEvicted(EntryEvent<String, String> event) {
				entryRemoved(event);
			}

			private void addOrUpdateRecord(String id, String serializedRecord) {
				MasterSerializer serializer = serializer();
				add(serializer.deserialize(serializedRecord));
			}

			@SuppressWarnings("all")
			private void notifyEntityListeners(EntryEvent<String, String> e, Event.Type type) {
				TripletRecord record = serializer().deserialize(e.getValue());
				MasterEntityEvent<?> event = new MasterEntityEvent<>(type, asEntity(record));
				List<EntityListener> listeners = entityListeners.get(record.type());
				if(listeners != null) listeners.forEach(listener -> listener.notify(event));
			}
    	}

		public static class MasterEntityEvent<T extends Entity> implements Event<T> {

			private final Type type;
			private final T entity;

			private MasterEntityEvent(Type type, T entity) {
				this.type = type;
				this.entity = entity;
			}

			@Override
			public Type type() {
				return type;
			}

			@Override
			public T entity() {
				return entity;
			}
		}
    }
end


def type(master & lazy)
	package $package;

	import com.hazelcast.client.HazelcastClient;
	import com.hazelcast.client.config.ClientConfig;
	import com.hazelcast.client.config.ClientNetworkConfig;
	import com.hazelcast.core.EntryAdapter;
	import com.hazelcast.core.EntryEvent;
	import com.hazelcast.core.HazelcastInstance;
	import com.hazelcast.map.IMap;
	import io.intino.ness.master.data.EntityListener;
	import io.intino.ness.master.data.EntityListener.Event;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.model.Triplet;
	import io.intino.ness.master.model.TripletRecord;
	import io.intino.ness.master.serialization.MasterSerializer;
	import io.intino.ness.master.serialization.MasterSerializers;
	import $package.entities.*;

	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import java.util.function.BiFunction;
	import java.util.logging.ConsoleHandler;
	import java.util.logging.Handler;
	import java.util.logging.Level;
	import java.util.logging.LogManager;
	import java.util.stream.Stream;

	import static io.intino.ness.master.core.Master.*;
	import static java.util.Objects.requireNonNull;

	public class LazyLoadMasterTerminal implements MasterTerminal {

    	private final MasterTerminal.Config config;
		private HazelcastInstance hazelcast;
		private IMap<String, String> masterMap;
		private MasterSerializer serializer;
		@SuppressWarnings("rawtypes")
		private final Map<String, List<EntityListener>> entityListeners = new HashMap<>();

    	public LazyLoadMasterTerminal(MasterTerminal.Config config) {
    		this.config = requireNonNull(config);
    	}

		@Override
		public void start() {
			configureLogger();
			initHazelcastClient();
		}

		@Override
    	public void stop() {
    		hazelcast.shutdown();
    	}

		@Override
    	public <T extends Entity> void addEntityListener(String type, EntityListener<T> listener) {
    		if(type == null) throw new NullPointerException("Type cannot be null");
    		if(listener == null) throw new NullPointerException("EntryListener cannot be null");
    		entityListeners.computeIfAbsent(type, k -> new ArrayList<>()).add(listener);
    	}

    	@Override
        public MasterSerializer serializer() {
        	return serializer;
        }

    	@Override
    	public MasterTerminal.Config config() {
    		return new MasterTerminal.Config(config);
    	}

    	$entity+getter...[$NL$NL]

    	private TripletRecord getRecord(String id) {
        	String serializedRecord = masterMap.get(id);
        	if(serializedRecord == null) return null;
        	return serializer.deserialize(serializedRecord);
        }

   		private <T extends Entity> T entity(BiFunction<String, MasterTerminal, T> constructor, String id, TripletRecord record) {
   			T entity = constructor.apply(id, this);
   			record.triplets().forEach(entity::add);
   			return entity;
   		}

		@Override
    	public void publish(Entity entity) {
    		if(!config.allowWriting()) throw new UnsupportedOperationException("This master client cannot publish because it is configured as read only");
			if(entity == null) throw new NullPointerException("Entity cannot be null");
			hazelcast.getTopic(REQUESTS_TOPIC).publish(config.instanceName() + MESSAGE_SEPARATOR + serializer().serialize(entity.asTripletRecord()));
    	}

    	private void initHazelcastClient() {
    		ClientConfig config = new ClientConfig();
        	config.setInstanceName(this.config.instanceName());
        	config.setNetworkConfig(new ClientNetworkConfig().setAddresses(this.config.addresses()));

        	hazelcast = HazelcastClient.newHazelcastClient(config);

        	masterMap = hazelcast.getMap(MASTER_MAP_NAME);
        	IMap<String, String> metadata = hazelcast.getMap(METADATA_MAP_NAME);
        	serializer = MasterSerializers.get(metadata.get("serializer"));

        	initListeners();
    	}

		private void initListeners() {
			hazelcast.getMap(MASTER_MAP_NAME).addEntryListener(new BaseEntryListener(), true);
		}

    	private static void configureLogger() {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger("");
			rootLogger.setLevel(Level.WARNING);
			for (Handler h : rootLogger.getHandlers()) rootLogger.removeHandler(h);
			final ConsoleHandler handler = new ConsoleHandler();
			handler.setLevel(Level.WARNING);
			handler.setFormatter(new io.intino.alexandria.logger.Formatter());
			rootLogger.setUseParentHandlers(false);
			rootLogger.addHandler(handler);
		}

    	public class BaseEntryListener extends EntryAdapter<String, String> {

			@Override
			public void entryAdded(EntryEvent<String, String> event) {
				notifyEntityListeners(event, Event.Type.Create);
			}

			@Override
			public void entryUpdated(EntryEvent<String, String> event) {
				notifyEntityListeners(event, Event.Type.Update);
			}

			@Override
			public void entryRemoved(EntryEvent<String, String> event) {
				notifyEntityListeners(event, Event.Type.Remove);
			}

			@Override
			public void entryEvicted(EntryEvent<String, String> event) {
				entryRemoved(event);
			}

			@SuppressWarnings("all")
			private void notifyEntityListeners(EntryEvent<String, String> e, Event.Type type) {
				TripletRecord record = serializer().deserialize(e.getValue());
				MasterEntityEvent<?> event = new MasterEntityEvent<>(type, asEntity(record));
				List<EntityListener> listeners = entityListeners.get(record.type());
				if(listeners != null) listeners.forEach(listener -> listener.notify(event));
			}
    	}

		public static class MasterEntityEvent<T extends Entity> implements Event<T> {

			private final Type type;
			private final T entity;

			private MasterEntityEvent(Type type, T entity) {
				this.type = type;
				this.entity = entity;
			}

			@Override
			public Type type() {
				return type;
			}

			@Override
			public T entity() {
				return entity;
			}
		}
    }
end


def !type(abstract) trigger(remover)
	case "$name+lowerCase": removeFrom$name+FirstUpperCase(id); break;
end

def !type(abstract) trigger(adder)
	case "$name+lowerCase": addTo$name+FirstUpperCase(record); break;
end

def !type(abstract) trigger(map)
	private final Map<String, $name+FirstUpperCase> $name+FirstLowerCase~Map = new ConcurrentHashMap<>();
end

def !type(abstract) trigger(add)
	private void addTo$name+FirstUpperCase(TripletRecord record) {
		$name+FirstUpperCase entity = new $name+FirstUpperCase(record.id(), this);
    	record.triplets().forEach(entity::add);
    	$name+firstLowerCase~Map.put(record.id(), entity);
    }
end

def !type(abstract) trigger(remove)
	private void removeFrom$name+FirstUpperCase(String id) {
		$name+firstLowerCase~Map.remove(id);
	}
end

def type(subclass) trigger(getById)
	case "$name+lowerCase": return $name+firstLowerCase(id);
end

def type(subclass) trigger(getAllStream)
	$name+Plural+firstLowerCase()
end

def type(abstract) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
    	switch(Triplet.typeOf(id)) {
    		$subclass+getById...[$NL]
    	}
    	return null;
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return Stream.of(
			$subclass+getAllStream...[,$NL]
		).flatMap(java.util.function.Function.identity());
	}
end

def !type(abstract) type(cached) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
		return $name+firstLowerCase~Map.get(id);
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return $name+firstLowerCase~Map.values().stream();
	}
end

def !type(abstract) type(lazy) trigger(getter)
	@Override
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
		TripletRecord record = getRecord(id);
    	return record != null ? entity($name+FirstUpperCase::new, id, record) : null;
	}

	@Override
	public Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return masterMap.entrySet().stream()
				.filter(e -> e.getKey().endsWith(":$name+firstLowerCase"))
				.map(e -> entity($name+FirstUpperCase::new, e.getKey(), serializer.deserialize(e.getValue())));
	}
end

def trigger(getterSignature)
	$name+FirstUpperCase $name+firstLowerCase(String id);
	Stream<$name+FirstUpperCase> $name+Plural+firstLowerCase();
	default List<$name+FirstUpperCase> $name+firstLowerCase~List() {return $name+Plural+firstLowerCase().collect(Collectors.toList());}
end

def trigger(entityListener)
	default void add$name+FirstUpperCase~EntityListener(EntityListener<$name+FirstUpperCase> listener) {
		addEntityListener("$name+firstLowerCase", listener);
	}
end

def type(entity) !type(abstract) trigger(asEntitySwitchCase)
	case "$name+firstLowerCase": return (T) new $name+FirstUpperCase(record, this);
end