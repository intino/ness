def type(datamart & interface)
	package $package;

	import java.util.List;
	import java.util.Map;
	import java.util.concurrent.ConcurrentHashMap;
	import java.util.stream.Stream;
	import java.util.stream.Collectors;
	import java.time.Instant;
	import java.util.Optional;

	import io.intino.ness.master.Datamart;
	import io.intino.ness.master.model.Entity;
	import io.intino.ness.master.reflection.*;

	public interface $name+FirstUpperCase~Datamart extends Datamart {

		DatamartDefinition definition = new $name+FirstUpperCase~Datamart.DatamartDefinitionInternal();

		List<String> listSnapshots();
		$name+FirstUpperCase~Datamart snapshot(String timetag);

		[$entity+getterSignature...[$NL$NL]]

		[$hasTimelines~Stream<TimelineNode> timelines(String id);]

		[$timeline+getterSignature...[$NL$NL]]

		[$hasReels~Stream<ReelNode> reels(String id);]

		[$reel+getterSignature...[$NL$NL]]

		Dictionary dictionary(String name);

		class Entities {

			private final $name+FirstUpperCase~Datamart datamart;
			private final Map<EntityDefinition, Map<String, $name+FirstUpperCase~Entity>> entitiesByType;

			public Entities($name+FirstUpperCase~Datamart datamart) {
				this.datamart = datamart;
				this.entitiesByType = new ConcurrentHashMap<>();
				datamart.getDefinition().entities().stream().filter(e -> !e.isAbstract()).forEach(entity -> entitiesByType.put(entity, new ConcurrentHashMap<>()));
			}

			public $name+FirstUpperCase~Datamart datamart() {
				return datamart;
			}

        	public int size() {
        		return entitiesByType.values().stream().mapToInt(Map::size).sum();
        	}

        	public boolean contains(String id) {
        		return get(id) != null;
        	}

        	public boolean contains(EntityDefinition definition, String id) {
        		return get(definition, id) != null;
        	}

        	public $name+FirstUpperCase~Entity get(String id) {
        		return mapOf(id).map(map -> map.get(id)).orElse(null);
        	}

        	public $name+FirstUpperCase~Entity getDescendant(EntityDefinition definition, String id) {
        		$name+FirstUpperCase~Entity entity = get(definition, id);
        		return entity != null ? entity : definition.descendants().stream()
        			.filter(descendant -> !descendant.isAbstract())
        			.map(descendant -> get(descendant, id))
        			.filter(java.util.Objects::nonNull).findFirst().orElse(null);
        	}

			@SuppressWarnings("unchecked")
        	public $name+FirstUpperCase~Entity get(EntityDefinition type, String id) {
        		return entitiesByType.containsKey(type) ? entitiesByType.get(type).get(id) : null;
            }

        	public void add($name+FirstUpperCase~Entity entity) {
        		entitiesByType.get(entity.getDefinition()).put(entity.id(), entity);
        	}

        	public void remove(String id) {
        		mapOf(id).ifPresent(map -> map.remove(id));
        	}

        	public Stream<$name+FirstUpperCase~Entity> stream() {
        		return entitiesByType.values().stream().flatMap(map -> map.values().stream());
        	}

        	public Stream<$name+FirstUpperCase~Entity> stream(EntityDefinition type) {
        		return entitiesByType.containsKey(type) ? entitiesByType.get(type).values().stream() : Stream.empty();
        	}

        	public Stream<Entity> streamGeneric() {
            	return entitiesByType.values().stream().flatMap(map -> map.values().stream());
            }

        	private java.util.Optional<Map<String, $name+FirstUpperCase~Entity>> mapOf(String id) {
        		return entitiesByType.values().stream().filter(map -> map.containsKey(id)).findFirst();
        	}
        }

        interface ChronosNode {
        	/**<p>Returns the id of the chronos object</p>*/
        	String id();
        	/**<p>Returns the type of the chronos object, as defined in the model</p>*/
        	String type();
        	/**Clears this node's internal cache, if any, and notifies the datamart to unload this node from memory.*/
        	void dispose();
        }

        interface TimelineNode extends ChronosNode {
        	java.util.concurrent.atomic.AtomicBoolean AlwaysDownloadFromDatahub = new java.util.concurrent.atomic.AtomicBoolean();
			boolean exists();
			io.intino.sumus.chronos.TimelineStore.TimeModel timeModel() throws TimelineNotAvailableException;
			io.intino.sumus.chronos.TimelineStore.SensorModel sensorModel() throws TimelineNotAvailableException;
			Instant first() throws TimelineNotAvailableException;
			Instant last() throws TimelineNotAvailableException;
        	io.intino.sumus.chronos.Timeline get() throws TimelineNotAvailableException;

        	void setEventListener(EventListener listener);

     		interface EventListener {
        		void onEventReceived(TimelineNode node, io.intino.alexandria.event.Event event);
        	}

        	static TimelineNode empty() {
        		return new TimelineNode() {
                    public String id(){return "";}
                    public String type(){return "";}
                    public void dispose(){}
                	public boolean exists() {return false;}
                	public io.intino.sumus.chronos.TimelineStore.TimeModel timeModel() throws TimelineNotAvailableException {throw new TimelineNotAvailableException();}
                	public io.intino.sumus.chronos.TimelineStore.SensorModel sensorModel() throws TimelineNotAvailableException {throw new TimelineNotAvailableException();}
                	public Instant first() throws TimelineNotAvailableException {throw new TimelineNotAvailableException();}
                	public Instant last() throws TimelineNotAvailableException {throw new TimelineNotAvailableException();}
                	public io.intino.sumus.chronos.Timeline get() throws TimelineNotAvailableException {throw new TimelineNotAvailableException();}
                	public void setEventListener(EventListener listener) {}
        		};
        	}
        }

        interface ReelNode extends ChronosNode {
			boolean exists();
        	java.time.Instant start() throws ReelNotAvailableException;
        	io.intino.sumus.chronos.State stateOf(String signal) throws ReelNotAvailableException;
			default List<io.intino.sumus.chronos.State> stateOf(List<String> signals) throws ReelNotAvailableException {return signals.isEmpty() ? java.util.Collections.emptyList() : stateOf(signals.stream());}
			List<io.intino.sumus.chronos.State> stateOf(Stream<String> signals) throws ReelNotAvailableException;
			io.intino.sumus.chronos.Shot lastShotOf(String signal) throws ReelNotAvailableException;
            List<io.intino.sumus.chronos.Shot> lastShots() throws ReelNotAvailableException;
            List<io.intino.sumus.chronos.Shot> lastShots(String group) throws ReelNotAvailableException;
            List<io.intino.sumus.chronos.Shot> lastShots(io.intino.sumus.chronos.Group group) throws ReelNotAvailableException;
        	io.intino.sumus.chronos.Reel get(io.intino.sumus.chronos.Period period) throws ReelNotAvailableException;
        	io.intino.sumus.chronos.Reel get(java.time.Instant from, java.time.Instant to, io.intino.sumus.chronos.Period period) throws ReelNotAvailableException;
        	void setEventListener(EventListener listener);

     		interface EventListener {
        		void onEventReceived(ReelNode node, io.intino.alexandria.event.Event event);
        	}

        	static ReelNode empty() {
        		return new ReelNode() {
        	        public String id(){return "";}
                    public String type(){return "";}
                    public void dispose(){}
        			public boolean exists() {return false;}
                	public java.time.Instant start() throws ReelNotAvailableException {throw new ReelNotAvailableException();}
                	public io.intino.sumus.chronos.State stateOf(String signal) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
                	public List<io.intino.sumus.chronos.State> stateOf(Stream<String> signals) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
                	public io.intino.sumus.chronos.Shot lastShotOf(String signal) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
					public List<io.intino.sumus.chronos.Shot> lastShots() throws ReelNotAvailableException{throw new ReelNotAvailableException();}
					public List<io.intino.sumus.chronos.Shot> lastShots(String group) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
					public List<io.intino.sumus.chronos.Shot> lastShots(io.intino.sumus.chronos.Group group) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
                	public io.intino.sumus.chronos.Reel get(io.intino.sumus.chronos.Period period) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
                	public io.intino.sumus.chronos.Reel get(java.time.Instant from, java.time.Instant to, io.intino.sumus.chronos.Period period) throws ReelNotAvailableException{throw new ReelNotAvailableException();}
                	public void setEventListener(EventListener listener) {}
        		};
        	}
        }

		final class DatamartDefinitionInternal implements DatamartDefinition {
			private DatamartDefinition definition;
			private DatamartDefinitionInternal() {}
			@Override
			public String name() {return definition().name();}
			@Override
			public Datamart.Scale scale() {return definition().scale();}
			@Override
			public Query<EntityDefinition> entities() {return definition().entities();}
			@Override
			public Query<StructDefinition> structs() {return definition().structs();}
			@Override
			public Optional<EntityDefinition> entity(String fullName) {
            	return definition().entity(fullName);
            }
            @Override
            public Optional<StructDefinition> struct(String fullName) {
            	return definition().struct(fullName);
            }
			private DatamartDefinition definition() {
				if (definition == null) throw new IllegalStateException("$name+FirstUpperCase~Datamart is not initialized");
				return definition;
			}
		}

		public static class DatahubRequestException extends Exception {
			public DatahubRequestException() {}
			public DatahubRequestException(String message) {super(message);}
			public DatahubRequestException(String message, Throwable cause) {super(message, cause);}
		}

		public static class TimelineNotAvailableException extends Exception {
        	public TimelineNotAvailableException() {}
        	public TimelineNotAvailableException(String message) {super(message);}
        	public TimelineNotAvailableException(Throwable e) {super(e);}
        }

		public static class ReelNotAvailableException extends Exception {
        	public ReelNotAvailableException() {}
        	public ReelNotAvailableException(String message) {super(message);}
        	public ReelNotAvailableException(Throwable e) {super(e);}
        }
	}
end

def type(datamart & message & impl)
	package $package;

	import io.intino.alexandria.Timetag;
	import io.intino.alexandria.event.Event;
	import io.intino.alexandria.logger.Logger;
	import io.intino.alexandria.terminal.Connector;
	import io.intino.ness.master.reflection.*;
	import io.intino.ness.master.model.Entity;

	import org.apache.activemq.command.ActiveMQTextMessage;

	import java.io.File;
	import java.util.*;
	import java.util.function.BiFunction;
	import java.util.concurrent.atomic.AtomicBoolean;
	import java.util.stream.Stream;
	import java.util.stream.Collectors;
	import java.time.LocalDate;
	import java.time.LocalDateTime;
	import java.time.Instant;

	import $ontologypackage.*;

	import static java.util.Objects.requireNonNull;

	public class $name+FirstUpperCase~DatamartImpl implements $name+FirstUpperCase~Datamart {

		private static final String DATAHUB_MESSAGE_TOPIC = "service.ness.datamarts";
		private static final $name+FirstUpperCase~DatamartImpl.$name+FirstUpperCase~DatamartDefinition definition = new $name+FirstUpperCase~DatamartImpl.$name+FirstUpperCase~DatamartDefinition();

		[private static final Set<String> TIMELINE_EVENTS = Set.of($timelineEvents);]
		[private static final Set<String> REEL_EVENTS = Set.of($reelEvents);]

		private final Connector connector;
		private final $terminal~.DatamartsRetryConfig retryConfig;
		private final AtomicBoolean initialized = new AtomicBoolean(false);
		private final List<EntityListener> entityListeners = new ArrayList<>();
		private final Map<String, List<MasterMounter>> mounters = new HashMap<>();
		private final $name+FirstUpperCase~Datamart.Entities entities;
		private Instant ts;
		[$hasTimelines~private boolean hasLocalAccessToTimelines;]
		[$hasTimelines~private final Map<String, TimelineNodeImpl> timelines = new java.util.concurrent.ConcurrentHashMap<>();]
		[$hasReels~private boolean hasLocalAccessToReels;]
		[$hasReels~private final Map<String, ReelNodeImpl> reels = new java.util.concurrent.ConcurrentHashMap<>();]
		private volatile DictionaryImpl dictionary = new DictionaryImpl();
		private final Map<Class<?>, BiFunction<EntityDefinition, String, $name+FirstUpperCase~EntityReference>> entityReferenceFactory = createEntityReferenceFactory();

    	public $name+FirstUpperCase~DatamartImpl(Connector connector, $terminal~.DatamartsRetryConfig retryConfig) {
    		this.connector = requireNonNull(connector);
    		this.retryConfig = requireNonNull(retryConfig);
    		this.entities = new $name+FirstUpperCase~Datamart.Entities(this);
    		initMounters();
    	}

		public synchronized $name+FirstUpperCase~DatamartImpl init(String datamartSourceSelector) {
			try {
				if (!initialized.compareAndSet(false, true)) return this;
				downloadDatamartFromDatahub(datamartSourceSelector);
				Logger.info("$name+FirstUpperCase~Datamart (" + (snapshotTimetag().isEmpty() ? "" : "snapshot " + snapshotTimetag() + ", ")  + connector.clientId() + ") initialized successfully.");
			} catch (Exception e) {
				throw new ExceptionInInitializerError("$name+FirstUpperCase~Datamart failed to start because a " + e.getClass().getName() + " occurred: " + e.getMessage());
			}
			return this;
		}

		@Override
		public int size() {
			return entities.size();
		}

		@Override
		@SuppressWarnings("unchecked")
		public <T extends Entity> T get(String id) {
			MasterEntity entity = entities.get(id);
			if (entity == null) return null;
			EntityDefinition definition = entity.getDefinition();
			Class<?> javaClass = definition.javaClass();
			return (T) entityReferenceFactory.getOrDefault(javaClass, (BiFunction<EntityDefinition, String, $name+FirstUpperCase~EntityReference>) ((a,b) -> null)).apply(definition, id);
		}

		@Override
		public Stream<Entity> entities() {
			return entities.streamGeneric();
		}

		@Override
		public void addEntityListener(EntityListener listener) {
			if (listener == null) throw new NullPointerException("EntityListener cannot be null");
			entityListeners.add(listener);
		}

		@Override
		public DatamartDefinition getDefinition() {
			return definition;
		}

		@Override
        public List<String> listSnapshots() {
        	try {
        		javax.jms.Message message = requestResponseFromDatahub("listSnapshots", listSnapshotsRequest());
        		if (!message.getBooleanProperty("success")) throw new Exception(((javax.jms.TextMessage) message).getText());
        		return handleListSnapshotsResponse(message);
        	} catch (Exception e) {
        		Logger.error("Could not download list of available snapshots: " + e.getMessage(), e);
        		return java.util.Collections.emptyList();
        	}
        }

        private javax.jms.Message listSnapshotsRequest() throws Exception {
        	ActiveMQTextMessage message = new ActiveMQTextMessage();
        	message.setText("datamart=" + name() + ";operation=snapshots");
        	return message;
        }

        private List<String> handleListSnapshotsResponse(javax.jms.Message message) throws Exception {
        	return java.util.Arrays.stream(((javax.jms.TextMessage) message).getText().split(",")).collect(Collectors.toList());
        }

        @Override
        public synchronized $name+FirstUpperCase~Datamart snapshot(String timetag) {
        	if (timetag == null) return this;
        	return new $name+FirstUpperCase~DatamartImpl(connector, retryConfig) {
        		@Override
        		protected String snapshotTimetag() {
        			return timetag;
        		}
        		@Override
        		public synchronized MasterDatamart snapshot(String timetag) {
        			throw new java.lang.UnsupportedOperationException("Cannot request snapshots to snapshot instances of a datamart");
        		}
        	}.init(null);
        }

        public Instant ts() {
        	return this.ts;
        }

    	[$entity+getter...[$NL$NL]]

		[$hasTimelines+timelinesByIdMethod]
    	[$timeline+getter...[$NL$NL]]

		[$hasReels+reelsByIdMethod]
    	[$reel+getter...[$NL$NL]]

    	@Override
    	public Dictionary dictionary() {
    		return dictionary;
    	}

    	@Override
        public Dictionary dictionary(String name) {
        	if (name == null) name = "";
        	if (dictionary.name.equals(name)) return dictionary;
        	loadDictionaryFromDatahub(name);
        	return dictionary;
        }

		private void downloadDatamartFromDatahub(String datamartSourceSelector) throws DatahubRequestException {
			if (connector instanceof io.intino.alexandria.terminal.StubConnector) return;
			Logger.debug("Downloading datamart from datahub...");
    		long start = java.lang.System.currentTimeMillis();

    		Logger.debug("Downloading entities...");
    		int$[$] eventCount = new int$[1$];
    		loadEntitiesFromEvents(downloadEntities(eventCount, datamartSourceSelector), eventCount);

    		[$hasTimelines~loadTimelinesFromDatahub();]

    		[$hasReels~loadReelsFromDatahub();]

    		[$hasDictionary~loadDictionaryFromDatahub("");]

			long time = java.lang.System.currentTimeMillis() - start;
			Logger.debug("Datamart downloaded from datahub after " + time + " ms");
		}

		[$hasTimelines+loadTimelinesFromDatahubMethod]

		[$hasReels+loadReelsFromDatahubMethod]

		[$hasDictionary+loadDictionaryFromDatahubMethod]

		private Stream<Event> downloadEntities(int$[$] eventCount, String datamartSourceSelector) throws DatahubRequestException {
			try {
				javax.jms.Message message = requestResponseFromDatahub("downloadEvents", downloadEntitiesRequest(datamartSourceSelector));
				if (!message.getBooleanProperty("success")) throw new Exception(((javax.jms.TextMessage) message).getText());
				return handleDownloadResponse(message, eventCount);
			} catch (NullPointerException e) {
				throw new DatahubRequestException("Could not download datamart: no response from datahub.");
			} catch(DatahubRequestException e) {
				throw e;
			} catch (Exception e) {
				throw new DatahubRequestException("Could not download datamart: " + e.getMessage());
			}
		}

		private javax.jms.Message downloadEntitiesRequest(String datamartSourceSelector) throws Exception {
			ActiveMQTextMessage message = new ActiveMQTextMessage();
			message.setText("datamart=" + name() +
				";operation=entities" +
				(snapshotTimetag().isEmpty() ? "" : ";timetag=" + snapshotTimetag()) +
				(datamartSourceSelector == null ? "" : ";sourceSelector=" + datamartSourceSelector)
			);
			return message;
		}

		protected String snapshotTimetag() {
			return "";
		}

		private Stream<Event> handleDownloadResponse(javax.jms.Message message, int$[$] eventCount) throws Exception {
			javax.jms.BytesMessage m = (javax.jms.BytesMessage) message;
			eventCount$[0$] = m.getIntProperty("size");
			int size = m.getIntProperty("size");
			byte$[$] bytes = new byte$[size$];
			m.readBytes(bytes, size);
			return io.intino.alexandria.zim.ZimStream.of(new java.io.ByteArrayInputStream(bytes)).map(io.intino.alexandria.event.message.MessageEvent::new);
		}

		private void loadEntitiesFromEvents(Stream<Event> events, int$[$] eventCount) {
			events.forEach(this::mount);
		}

		public synchronized void mount(Event event) {
			if (event == null) return;
			this.ts = event.ts();
			mountEntities(event);
			[$hasTimelines~mountTimelines(event);]
			[$hasReels~mountReels(event);]
			// TODO: update dictionary when resource event arrives
		}

		[$hasReels~private void mountReels(Event event) {
			if (!REEL_EVENTS.contains(event.type())) return;
			String id = sensorParameter(event.ss());
			String type = event.type();
			String key = id + ":" + type;
			if (!reels.containsKey(key)) {
				ReelNodeImpl node = new ReelNodeImpl(id, type, sourcesOfReel(type), null);
				reels.put(key, node);
			}
			reels.values().forEach(reel -> reel.notifyEvent(event));
		}]

		[$hasTimelines~private void mountTimelines(Event event) {
			if (!TIMELINE_EVENTS.contains(event.type())) return;
			String id = sensorParameter(event.ss());
			String type = event.type();
			TimelineNodeImpl node = timelines.computeIfAbsent(id + ":" + type, k -> new TimelineNodeImpl(id, type, sourcesOfTimeline(type), null));
			node.notifyEvent(event);
		}]

		private static String sensorParameter(String ss) {
			if (ss.contains("?")) {
				try {
					Map<String, String> map = Arrays.stream(ss.substring(ss.indexOf("?") + 1).split(";"))
							.map(p -> p.split("="))
							.collect(Collectors.toMap(f -> f$[0], f -> f$[1]));
					if (map.containsKey("sensor")) return map.get("sensor");
					else ss.substring(0, ss.indexOf("?"));
				} catch (Exception e) {
					Logger.error(e);
				}
			}
			return ss;
		}

		private void mountEntities(Event event) {
			try {
				java.util.Optional.ofNullable(this.mounters.get(event.type())).ifPresent(mounters -> mounters.forEach(mounter -> mounter.mount(event)));
			} catch (Exception e) {
				Logger.error("Failed to mount event of type " + event.type() + ": " + e.getMessage(), e);
			}
		}

		private void initMounters() {
			[$entity+registerMounter...[$NL]]
		}

		private static int availableThreads() {
			return Runtime.getRuntime().availableProcessors();
		}

		private javax.jms.Message requestResponseFromDatahub(String requestName, javax.jms.Message request) throws DatahubRequestException {
        	long timeout = retryConfig.initialTimeoutAmount;
        	for(int i = 0; i < retryConfig.maxAttempts; i++) {
        		javax.jms.Message message = connector.requestResponse(DATAHUB_MESSAGE_TOPIC, request, timeout, retryConfig.timeoutUnit);
        		if (message != null) return message;
        		if (i < retryConfig.maxAttempts - 1) Logger.warn("("+(i+1)+") Datahub did not respond after " + timeout + " " + retryConfig.timeoutUnit + " to the request '" + requestName + "'. Trying again...");
        		timeout *= retryConfig.timeoutMultiplier;
        	}
        	throw new DatahubRequestException("Datahub did not respond to the request '" + requestName + "' after " + retryConfig.maxAttempts);
        }

		[$timelineNode+nodeImpl]

		[$reelNode+nodeImpl]

		[$dictionary+dictionaryImpl]

		private static Set<String> sourcesOfTimeline(String type) {
        	return switch(type) {
        		[$timeline+sourcesSwitchCase...[$NL]]
        		default -> java.util.Collections.emptySet();
        	};
        }

		private static Set<String> sourcesOfReel(String type) {
        	return switch(type) {
        		[$reel+sourcesSwitchCase...[$NL]]
        		default -> java.util.Collections.emptySet();
        	};
        }

        Map<Class<?>, BiFunction<EntityDefinition, String, $name+FirstUpperCase~EntityReference>> createEntityReferenceFactory() {
        	Map<Class<?>, BiFunction<EntityDefinition, String, $name+FirstUpperCase~EntityReference>> map = new HashMap<>();
        	$entity+referenceFactoryEntry...[$NL]
        	return map;
        }

		// WARNING: extremely compacted and ugly code ahead... continue at your own discretion.
		public static final class $name+FirstUpperCase~DatamartDefinition implements DatamartDefinition {

			@Override
			public String name() {
				return "$name";
			}

			@Override
			public Scale scale() {
				return Scale.$scale;
			}

			@Override
			public Query<EntityDefinition> entities() {
				return new Query<EntityDefinition>(List.of([$entity+definition...[,]]));
			}

			@Override
			public Query<StructDefinition> structs() {
				return new Query<StructDefinition>(List.of([$struct+definition...[,]]));
			}

			@Override
			public Optional<EntityDefinition> entity(String name) {
				switch(name) {
					[$entity+defSwitchCase...[$NL]]
				}
				return Optional.empty();
			}

			@Override
        	public Optional<StructDefinition> struct(String name) {
        		switch(name) {
        			[$struct+defSwitchCase...[$NL]]
        		}
        		return Optional.empty();
        	}

			private $name+FirstUpperCase~DatamartDefinition datamart() {
				return this;
			}

			[$entity+declareDefinition...[$NL]]

            [$struct+declareDefinition...[$NL]]
		}

		static {
			try {
				Object ref = $name+firstUpperCase~Datamart.class.getDeclaredField("definition").get(null);
				java.lang.reflect.Field field = ref.getClass().getDeclaredField("definition");
				field.setAccessible(true);
				field.set(ref, definition);
				field.setAccessible(false);
			} catch (Exception e) {
				throw new ExceptionInInitializerError("Could not set $name+firstUpperCase~Datamart.definition field");
			}
		}
    }
end

def type(entity) !type(abstract) trigger(referenceFactoryEntry)
	map.put($package.entities.$name+FirstUpperCase.class, (definition, id) -> new $package.entities.$name+FirstUpperCase~(() -> entities.get(definition, id)));
end

def type(entity) trigger(definition)
	$name+firstLowerCase~EntityDefinition
end

def type(struct) trigger(definition)
	$fullName+firstLowerCase~StructDefinition
end

def type(entity) trigger(defSwitchCase)
	case "$name+FirstUpperCase": return Optional.of($name+firstLowerCase~EntityDefinition);
end

def type(struct) trigger(defSwitchCase)
	case "$fullName+FirstUpperCase": return Optional.of($fullName+firstLowerCase~StructDefinition);
end

def type(entity) trigger(declareDefinition)
	public final EntityDefinition $name+firstLowerCase~EntityDefinition = new EntityDefinition() {
		private final List<AttributeDefinition> declaredAttributes = initAttributeDefinitions();
		public String fullName() {return "$fullName";}
		public String name() {return "$name";}
		public boolean isAbstract() {return $isAbstract;}
		public List<AttributeDefinition> declaredAttributes() {	return declaredAttributes;}
		public Optional<EntityDefinition> parent() {return [Optional.of($parent+firstLowerCase~EntityDefinition)?Optional.empty()];}
		public List<EntityDefinition> ancestors() {return java.util.List.of([$ancestor+definition...[,]]);}
		public List<EntityDefinition> descendants() {return java.util.List.of([$descendant+definition...[,]]);}
		public Class<?> javaClass() {return $package.entities.$name+FirstUpperCase.class;}
		private List<AttributeDefinition> initAttributeDefinitions() {
			List<AttributeDefinition> list = new ArrayList<>();
			[$hasNoParents+addIdAndEnabledAttributes]
        	[$attribute+addDefinition...[$NL]]
        	return Collections.synchronizedList(list);
		}
		public boolean equals(Object other) {
			if (other == null || other.getClass() != getClass()) return false;
			return fullName().equals(((EntityDefinition)other).fullName());
		}
		public int hashCode() {return fullName().hashCode();}
		public String toString() {return fullName();}
	};
end

def type(struct) trigger(declareDefinition)
	public final StructDefinition $fullName+firstLowerCase~StructDefinition = new StructDefinition() {
		private final List<AttributeDefinition> declaredAttributes = initAttributeDefinitions();
		public String fullName() {return "$fullName";}
		public String name() {return "$name";}
		public List<AttributeDefinition> declaredAttributes() {return declaredAttributes;}
		public Optional<StructDefinition> parent() {return [Optional.of($parent+firstLowerCase~StructDefinition)?Optional.empty()];}
		public List<StructDefinition> ancestors() {return java.util.List.of([$ancestor+definition...[,]]);}
		public List<StructDefinition> descendants() {return java.util.List.of([$descendant+definition...[,]]);}
		public Class<?> javaClass() {return $package.$name+FirstUpperCase.class;}
		private List<AttributeDefinition> initAttributeDefinitions() {
			List<AttributeDefinition> list = new ArrayList<>($numAttributes);
        	[$attribute+addDefinition...[$NL]]
        	return Collections.synchronizedList(list);
		}
		public boolean equals(Object other) {
        	if (other == null || other.getClass() != getClass()) return false;
        	return fullName().equals(((StructDefinition)other).fullName());
        }
        public int hashCode() {return fullName().hashCode();}
        public String toString() {return fullName();}
	};
end

def type(subclass) trigger(name)
	"$name+FirstUpperCase"
end

def type(entity) type(descendant | ancestor) trigger(definition)
	$name+FirstUpperCase~EntityDefinition
end

def type(struct) type(descendant | ancestor) trigger(definition)
	$name+FirstUpperCase~StructDefinition
end

def trigger(addIdAndEnabledAttributes)
	list.add(new AttributeDefinition() {
		public String name() {return "id";}
		public Class<?> type() {return String.class;}
		public String toString() {return name();}
	});
	list.add(new AttributeDefinition() {
		public String name() {return "enabled";}
		public Class<?> type() {return Boolean.class;}
		public String toString() {return name();}
	});
end

def type(attribute) !type(inherited) type(collection) trigger(addDefinition)
	list.add(new AttributeDefinition() {
		public String name() {return "$name+firstLowerCase";}
		public Class<?> type() {return $type~.class;}
		public String toString() {return name();}
		public List<ParameterDefinition> parameters() {
			return List.of(new ParameterDefinition() {
				public Optional<ConceptDefinition<?>> asConceptDefinition() {return $parameter+asConceptDefinition;}
				public Class<?> javaClass() {return $parameterType~.class;}
				public String toString() {return javaClass().getSimpleName();}
			});
		}
	});
end

def type(attribute) !type(inherited) trigger(addDefinition)
	list.add(new AttributeDefinition() {
		public String name() {return "$name+firstLowerCase";}
		public Class<?> type() {return $type~.class;}
		public String toString() {return name();}
	});
end

def type(parameter) type(entity) trigger(asConceptDefinition)
	Optional.of(datamart().$name+firstLowerCase~EntityDefinition)
end

def type(parameter) type(struct) trigger(asConceptDefinition)
	Optional.of(datamart().$name+firstLowerCase~StructDefinition)
end

def type(parameter) trigger(asConceptDefinition)
	Optional.empty()
end

def !type(abstract) type(entity) trigger(registerMounter)
	mounters.computeIfAbsent("$event+firstUpperCase", type -> new ArrayList<>(1)).add(new $package.mounters.$name+FirstUpperCase~Mounter(entities, entityListeners));
end

def type(subclasstop) trigger(getAllStream)
	$name+Plural+firstLowerCase()
end

def type(timeline) trigger(getter)
	@Override
	public TimelineNode $name+FirstLowerCase~Timeline(String id) {
		if (hasLocalAccessToTimelines) return timelines.containsKey(id.replace(":", "-") + ":$name") ? timelines.get(id.replace(":", "-") + ":$name") : TimelineNode.empty();
		return timelines.computeIfAbsent(id.replace(":", "-") + ":$name", theId -> new TimelineNodeImpl(id, "$name", Set.of($sources)));
	}
end

def type(reel) trigger(getter)
	@Override
	public ReelNode $name+FirstLowerCase~Reel(String id) {
		if (hasLocalAccessToReels) return reels.containsKey(id.replace(":", "-") + ":$name") ? reels.get(id.replace(":", "-") + ":$name") : ReelNode.empty();
		return reels.computeIfAbsent(id.replace(":", "-") + ":$name", theId -> new ReelNodeImpl(id, "$name", Set.of($sources)));
	}

	@Override
	public Stream<ReelNode> $name+FirstLowerCase~Reels() {
		Stream stream = reels.values().stream().filter(r -> r.type.equals("$name")).toList().stream();
		return stream;
	}
end

def trigger(timelinesByIdMethod)
	@Override
	public Stream<TimelineNode> timelines(String id) {
		Stream stream = timelines.values().stream().filter(t -> t.id.equals(id)).toList().stream();
		return stream;
	}
end

def trigger(reelsByIdMethod)
	@Override
	public Stream<ReelNode> reels(String id) {
		Stream stream = reels.values().stream().filter(r -> r.id.equals(id)).toList().stream();
		return stream;
	}
end

def trigger(sourcesSwitchCase)
	case "$name" -> Set.of($sources);
end

def type(abstract) trigger(getter)
	@Override
	public $package.entities.$name+FirstUpperCase $name+firstLowerCase(String id) {
		if (id == null) return null;
		var entity = entities.getDescendant(definition.$name+firstLowerCase~EntityDefinition, id);
		if (entity == null) return null;
		EntityDefinition definition = entity.getDefinition();
		Class<?> javaClass = definition.javaClass();
		return ($package.entities.$name+FirstUpperCase) entityReferenceFactory.getOrDefault(javaClass, (BiFunction<EntityDefinition, String, $datamart+FirstUpperCase~EntityReference>) ((a,b) -> null)).apply(definition, id);
	}

	@Override
	public Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return Stream.of(
			$subclasstop+getAllStream...[,$NL]
		).<$package.entities.$name+FirstUpperCase>flatMap(java.util.function.Function.identity());//.distinct();
	}
end

def type(superclass) !type(abstract) trigger(getter)
	@Override
	public $package.entities.$name+FirstUpperCase $name+firstLowerCase(String id) {
		if (id == null) return null;
		var entity = entities.getDescendant(definition.$name+firstLowerCase~EntityDefinition, id);
		if (entity == null) return null;
		EntityDefinition definition = entity.getDefinition();
		Class<?> javaClass = definition.javaClass();
		return ($package.entities.$name+FirstUpperCase) entityReferenceFactory.getOrDefault(javaClass, (BiFunction<EntityDefinition, String, $datamart+FirstUpperCase~EntityReference>) ((a,b) -> null)).apply(definition, id);
	}

	@Override
	public Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return Stream.of(
			entities.<$package.entities.$name+FirstUpperCase>stream(definition.$name+firstLowerCase~EntityDefinition).map(Entity::id).map(id -> new $package.entities.$name+FirstUpperCase(() -> entities.get(definition.$name+firstLowerCase~EntityDefinition, id))),
			$subclasstop+getAllStream...[,$NL]
		).<$package.entities.$name+FirstUpperCase>flatMap(java.util.function.Function.identity());//.distinct();
	}
end

def trigger(getter)
	@Override
	public $package.entities.$name+FirstUpperCase $name+firstLowerCase(String id) {
		return id == null || !entities.contains(definition.$name+firstLowerCase~EntityDefinition, id) ? null : new $package.entities.$name+FirstUpperCase(() -> entities.get(definition.$name+firstLowerCase~EntityDefinition, id));
	}

	@Override
	public Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return entities.stream(definition.$name+firstLowerCase~EntityDefinition)
			.map(Entity::id)
			.map(this::$name+firstLowerCase)
			.filter(java.util.Objects::nonNull);
	}
end

def type(entity) trigger(getterSignature)
	$package.entities.$name+FirstUpperCase $name+firstLowerCase(String id);
	Stream<$package.entities.$name+FirstUpperCase> $name+Plural+firstLowerCase();
	default List<$package.entities.$name+FirstUpperCase> $name+firstLowerCase~List() {return $name+Plural+firstLowerCase().collect(Collectors.toList());}
	default java.util.Optional<$package.entities.$name+FirstUpperCase> $name+firstLowerCase~(java.util.function.Predicate<$package.entities.$name+FirstUpperCase~> predicate) {return $name+Plural+firstLowerCase().filter(predicate).findFirst();}
end

def type(timeline) trigger(getterSignature)
	default TimelineNode $name+firstLowerCase~Timeline($package.entities.$entity+firstUpperCase entity) {return $name+firstLowerCase~Timeline(entity.id());}
	TimelineNode $name+firstLowerCase~Timeline(String id);
end

def type(reel) trigger(getterSignature)
	default ReelNode $name+firstLowerCase~Reel($package.entities.$entity+firstUpperCase entity) {return $name+firstLowerCase~Reel(entity.id());}
	ReelNode $name+firstLowerCase~Reel(String id);
	Stream<ReelNode> $name+firstLowerCase~Reels();
end

def trigger(loadTimelinesFromDatahubMethod)
	private void loadTimelinesFromDatahub() {
		Logger.debug("Downloading timelines...");
		Boolean hasLocalAccessToTimelines = null;
        for(String filename : listTimelineFiles()) {
        	if (filename == null || filename.isBlank()) continue;
        	try {
               	File file = new File(filename);
               	String id = file.getName().replace(".timeline", "");
               	String type = file.getParentFile().getName();
               	TimelineNodeImpl node = new TimelineNodeImpl(id, type, sourcesOfTimeline(type), file.exists() ? file : null);
               	timelines.put(id + ":" + type, node);
               	if (hasLocalAccessToTimelines == null) hasLocalAccessToTimelines = file.exists();
               	else hasLocalAccessToTimelines &= file.exists();
            } catch (Exception e) {
               	Logger.debug("Could not load timeline " + filename + " -> " + e.getClass().getSimpleName() + ": " + e.getMessage());
            }
        }
        this.hasLocalAccessToTimelines = hasLocalAccessToTimelines != null && hasLocalAccessToTimelines;
        Logger.debug("Loaded " + timelines.size() + " timelines (hasLocalAccessToTimelines=" + this.hasLocalAccessToTimelines + ")");
    }

    private String$[$] listTimelineFiles() {
    	try {
    		ActiveMQTextMessage request = new ActiveMQTextMessage();
    		request.setText("datamart=" + name() + ";operation=list-timelines;");
    		javax.jms.Message message = requestResponseFromDatahub("list-timelines", request);
    		if (!message.getBooleanProperty("success")) throw new Exception(((javax.jms.TextMessage) message).getText());
    		return ((javax.jms.TextMessage)message).getText().split(",");
    	} catch (Exception e) {
    		Logger.error(e);
    		return new String$[0$];
    	}
    }
end

def trigger(loadReelsFromDatahubMethod)
	private void loadReelsFromDatahub() {
		Logger.debug("Downloading reels...");
		Boolean hasLocalAccessToReels = null;
    	for(String filename : listReelFiles()) {
    		if (filename == null || filename.isBlank()) continue;
    		try {
    	    	File file = new File(filename);
    	    	String id = file.getName().replace(".reel", "");
    	    	String type = file.getParentFile().getName();
    	    	ReelNodeImpl node = new ReelNodeImpl(id, type, sourcesOfReel(type), file.exists() ? file : null);
    	    	reels.put(id + ":" + type, node);
    	    	if (hasLocalAccessToReels == null) hasLocalAccessToReels = file.exists();
                else hasLocalAccessToReels &= file.exists();
    	    } catch (Exception e) {
    	    	Logger.debug("Could not load reel " + filename + " -> " + e.getClass().getSimpleName() + ": " + e.getMessage());
    	    }
    	}
    	this.hasLocalAccessToReels = hasLocalAccessToReels != null && hasLocalAccessToReels;
    	Logger.debug("Loaded " + reels.size() + " reels");
    }

    private String$[$] listReelFiles() {
    	try {
    		ActiveMQTextMessage request = new ActiveMQTextMessage();
    		request.setText("datamart=" + name() + ";operation=list-reels;");
    		javax.jms.Message message = requestResponseFromDatahub("list-reels", request);
    		if (!message.getBooleanProperty("success")) throw new Exception(((javax.jms.TextMessage) message).getText());
    		return ((javax.jms.TextMessage)message).getText().split(",");
    	} catch (Exception e) {
    		Logger.error(e);
    		return new String$[0$];
    	}
    }
end

def trigger(loadDictionaryFromDatahubMethod)
	private void loadDictionaryFromDatahub(String name) {
		Logger.debug("Downloading dictionary...");
		Map<String, Map<String, String>> words = new HashMap<>();
		var entries = dictionaryEntries(name);
    	for(var triplet : entries) {
    		words.computeIfAbsent(triplet$[0$], k -> new HashMap<>(4)).put(triplet$[1$], triplet$[2$]);
    	}
    	this.dictionary = new DictionaryImpl(name, words);
    	Logger.debug("Loaded dictionary " + name + " with " + words.size() + " words");
    }

    private String$[$]$[$] dictionaryEntries(String name) {
    	try {
    		ActiveMQTextMessage request = new ActiveMQTextMessage();
    		request.setText("datamart=" + name() + ";operation=get-dictionary;name="+name);
    		javax.jms.Message message = requestResponseFromDatahub("get-dictionary", request);
    		if (message == null) return new String$[0$]$[0$];
    		if (!message.getBooleanProperty("success")) throw new Exception(((javax.jms.TextMessage) message).getText());
    		String text = ((javax.jms.TextMessage) message).getText();
    		if (text == null) return new String$[0$]$[0$];
    		return java.util.Arrays.stream(text.split("\\n"))
    			.filter(l -> !l.isBlank())
    			.map(l -> l.trim().split("\\t", -1))
    			.filter(t -> t.length >= 3)
    			.toArray(String$[$]$[$]::new);
    	} catch (Exception e) {
    		Logger.error(e);
    		return new String$[0$]$[0$];
    	}
    }
end

