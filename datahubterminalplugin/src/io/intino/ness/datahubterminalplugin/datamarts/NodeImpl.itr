def type(timelineNode & default) trigger(nodeImpl)

	private class TimelineNodeImpl implements TimelineNode {

		private final String id;
		private final String type;
		private final Set<String> sources;
		private volatile File file;
		private volatile boolean hasDirectAccessToFile;
		private volatile io.intino.sumus.chronos.TimelineStore timelineFile;
		private volatile java.lang.ref.SoftReference<io.intino.sumus.chronos.Timeline> cache;
		private volatile EventListener listener;
		private volatile boolean disposed;

		private TimelineNodeImpl(String id, String type, Set<String> sources) {
			this(id, type, sources, null);
		}

		private TimelineNodeImpl(String id, String type, Set<String> sources, File file) {
			this.id = requireNonNull(id);
			this.type = requireNonNull(type);
			this.sources = requireNonNull(sources);
			this.file = file;
			this.hasDirectAccessToFile = file != null;
		}

		@Override
		public String id() {
			return id;
		}

		@Override
		public String type() {
			return type;
		}


        public boolean exists() {
        	return timelineFile() != null;
        }

		@Override
		public void dispose() {
			synchronized(this) {
				if (disposed) return;
				clearCache();
				listener = null;
				timelines.remove(id + ":" + type);
				disposed = true;
			}
		}

		@Override
		public io.intino.sumus.chronos.TimelineStore.TimeModel timeModel() {
			return timelineFile().timeModel();
		}

		@Override
		public io.intino.sumus.chronos.TimelineStore.SensorModel sensorModel() {
			return timelineFile().sensorModel();
		}

		@Override
		public Instant first() {
			return timelineFile().first();
		}

		@Override
		public Instant last() {
			return timelineFile().last();
		}

		@Override
		public io.intino.sumus.chronos.Timeline get() {
			synchronized(this) {
				if (disposed) throw new IllegalStateException("This " + getClass().getSimpleName() + " is disposed.");
				try {
					if (cache != null) {
						io.intino.sumus.chronos.Timeline timeline = cache.get();
						if (timeline != null) return timeline;
					}
					io.intino.sumus.chronos.Timeline timeline = timelineFile().timeline();
					cache = new java.lang.ref.SoftReference<>(timeline);
					return timeline;
				} catch(RuntimeException e) {
					throw e;
				} catch(Exception e) {
					throw new RuntimeException(e);
				}
			}
		}

		private io.intino.sumus.chronos.TimelineStore timelineFile() {
			synchronized(this) {
				if (disposed) throw new IllegalStateException("This " + getClass().getSimpleName() + " is disposed.");
				try {
					if (timelineFile != null) return timelineFile;
					return timelineFile = (!TimelineNode.AlwaysDownloadFromDatahub.get() && file != null && file.exists())
						? loadFile()
						: downloadFromDatahub();
				} catch(RuntimeException e) {
					throw e;
				} catch(Exception e) {
					throw new TimelineNotAvailableException(e);
				}
			}
		}

		@Override
		public void setEventListener(EventListener listener) {
			this.listener = listener;
		}

		private void notifyEvent(io.intino.alexandria.event.Event event) {
			synchronized(this) {
				if (disposed) return;
				try {
					if (!sources.contains(event.type())) return;
					clearCache();
					if (listener != null) listener.onEventReceived(this, event);
				} catch(Throwable ignored) {}
			}
		}

		private void clearCache() {
			if (cache != null) {
				cache.enqueue();
				cache = null;
			}
			timelineFile = null;
			if(!hasDirectAccessToFile) file = null;
		}

		private io.intino.sumus.chronos.TimelineStore loadFile() throws Exception {
			return io.intino.sumus.chronos.TimelineStore.of(file);
		}

		private io.intino.sumus.chronos.TimelineStore downloadFromDatahub() throws Exception {
			javax.jms.Message response = requestResponseFromDatahub(
				"get-timeline=" + id(),
			 	request(TimelineNode.AlwaysDownloadFromDatahub.get() ? "download" : "path"));
			if (!response.getBooleanProperty("success")) throw new TimelineNotAvailableException("Could not get timeline " + id + " because datahub returned success=false in the response");;
			if (response instanceof javax.jms.TextMessage textResponse) {
				file = getFile(textResponse);
				hasDirectAccessToFile = true;
				if (file != null && file.exists()) return loadFile();
				file = null;
				hasDirectAccessToFile = false;
				response = requestResponseFromDatahub("get-timeline=" + id(), request("download"));
			}
			if (!response.getBooleanProperty("success")) throw new TimelineNotAvailableException("Could not get timeline " + id + " because datahub returned success=false in the response");;
			return readFromBytes((javax.jms.BytesMessage) response);
		}

		private io.intino.sumus.chronos.TimelineStore readFromBytes(javax.jms.BytesMessage m) throws Exception {
			int size = m.getIntProperty("size");
			byte$[$] bytes = new byte$[size$];
			m.readBytes(bytes, size);

			file = File.createTempFile(id(), ".timeline");
			java.nio.file.Files.write(file.toPath(), bytes, java.nio.file.StandardOpenOption.CREATE);
			file.deleteOnExit();
			hasDirectAccessToFile = false;

			return loadFile();
		}

		private File getFile(javax.jms.TextMessage m) {
			try {
				return new File(m.getText());
			} catch(Exception e) {
				return null;
			}
		}

		private javax.jms.Message request(String mode) throws Exception {
			ActiveMQTextMessage message = new ActiveMQTextMessage();
			String command = "datamart=" + name() + ";operation=get-timeline;id=" + id() + ";mode=" + mode + ";type=" + type;
			message.setText(command);
			return message;
		}

		public static class TimelineNotAvailableException extends RuntimeException {
			public TimelineNotAvailableException(String message) {super(message);}
			public TimelineNotAvailableException(Throwable e) {super(e);}
		}
	}
end

def type(reelNode & default) trigger(nodeImpl)

	private class ReelNodeImpl implements ReelNode {
		private final String id;
		private final String type;
		private final Set<String> sources;
		private volatile File file;
		private volatile boolean hasDirectAccessToFile;
		private volatile io.intino.sumus.chronos.ReelFile reelFile;
		private volatile EventListener listener;
		private volatile boolean disposed;

		private ReelNodeImpl(String id, String type, Set<String> sources) {
			this(id, type, sources, null);
		}

		private ReelNodeImpl(String id, String type, Set<String> sources, File file) {
			this.id = requireNonNull(id);
			this.type = requireNonNull(type);
			this.sources = requireNonNull(sources);
			this.file = file;
			this.hasDirectAccessToFile = file != null;
		}

		@Override
		public String id() {
			return id;
		}

		@Override
		public String type() {
			return type;
		}

		@Override
		public void dispose() {
			synchronized(this) {
				if (disposed) return;
				clearCache();
				listener = null;
				reels.remove(id + ":" + type);
				disposed = true;
			}
		}

		@Override
		public io.intino.sumus.chronos.ReelFile.Group groupOf(String signal) {
			io.intino.sumus.chronos.ReelFile reelFile = reelFile();
			if (reelFile == null) return null;
			return reelFile.groupOf(signal);
		}

		@Override
		public java.time.Instant start() {
			io.intino.sumus.chronos.ReelFile reelFile = reelFile();
			if (reelFile == null) return null;
			return reelFile.start();
		}

		@Override
		public io.intino.sumus.chronos.Reel.State stateOf(String signal) {
			io.intino.sumus.chronos.ReelFile reelFile = reelFile();
			return reelFile.stateOf(signal);
		}

		@Override
		public List<io.intino.sumus.chronos.Reel.State> stateOf(Stream<String> signals) {
			io.intino.sumus.chronos.ReelFile reelFile = reelFile();
			return signals.map(reelFile::stateOf).toList();
		}

		@Override
        public io.intino.sumus.chronos.Reel get(io.intino.sumus.chronos.Period period) {
        	io.intino.sumus.chronos.ReelFile reelFile = reelFile();
        	return reelFile().reel().by(period);
        }

		@Override
        public io.intino.sumus.chronos.Reel get(Instant from, Instant to, io.intino.sumus.chronos.Period period) {
        	io.intino.sumus.chronos.ReelFile reelFile = reelFile();
        	return reelFile.reel(from, to).by(period);
        }

        public boolean exists() {
        	return reelFile() != null;
        }

		private io.intino.sumus.chronos.ReelFile reelFile() {
			synchronized(this) {
				if (disposed) throw new IllegalStateException("This " + getClass().getSimpleName() + " is disposed.");
				try {
					if (reelFile != null) return reelFile;
					return reelFile = (file != null && file.exists())
						? loadFile()
						: downloadFromDatahub();
				} catch(RuntimeException e) {
					throw e;
				} catch (Exception e) {
					throw new ReelNotAvailableException(e);
				}
			}
		}

		@Override
		public void setEventListener(EventListener listener) {
			this.listener = listener;
		}

		private void notifyEvent(io.intino.alexandria.event.Event event) {
			synchronized(this) {
				if (disposed) return;
				try {
					if (!sources.contains(event.type())) return;
					clearCache();
					if (listener != null) listener.onEventReceived(this, event);
				} catch(Throwable ignored) {}
			}
		}

		private void clearCache() {
			reelFile = null;
			if(!hasDirectAccessToFile) file = null;
		}

		private io.intino.sumus.chronos.ReelFile loadFile() throws Exception {
			return io.intino.sumus.chronos.Reel~File.open(file);
		}

		private io.intino.sumus.chronos.ReelFile downloadFromDatahub() throws Exception {
			javax.jms.Message response = requestResponseFromDatahub("get-reel=" + id(), request("path"));
			if (!response.getBooleanProperty("success")) throw new ReelNotAvailableException("Could not get reel " + id + " because datahub returned success=false in the response");
			if (response instanceof javax.jms.TextMessage textResponse) {
				file = getFile(textResponse);
				hasDirectAccessToFile = true;
				if (file != null && file.exists()) return loadFile();
				file = null;
				hasDirectAccessToFile = false;
				response = requestResponseFromDatahub("get-reel=" + id(), request("download"));
			}
			if (!response.getBooleanProperty("success")) throw new ReelNotAvailableException("Could not get reel " + id + " because datahub returned success=false in the response");
			return readFromBytes((javax.jms.BytesMessage) response);
		}

		private io.intino.sumus.chronos.ReelFile readFromBytes(javax.jms.BytesMessage m) throws Exception {
			int size = m.getIntProperty("size");
			byte$[$] bytes = new byte$[size$];
			m.readBytes(bytes, size);
			file = File.createTempFile(id(), ".reel");
			java.nio.file.Files.write(file.toPath(), bytes, java.nio.file.StandardOpenOption.CREATE);
			file.deleteOnExit();
			hasDirectAccessToFile = false;
			return loadFile();
		}

		private File getFile(javax.jms.TextMessage m) {
			try {
				return new File(m.getText());
			} catch(Exception e) {
				return null;
			}
		}

		private javax.jms.Message request(String mode) throws Exception {
			ActiveMQTextMessage message = new ActiveMQTextMessage();
			String command = "datamart=" + name() + ";operation=get-reel;id=" + id() + ";mode=" + mode + ";type=" + type;
			message.setText(command);
			return message;
		}

		public static class ReelNotAvailableException extends RuntimeException {
			public ReelNotAvailableException(String message) {super(message);}
			public ReelNotAvailableException(Throwable e) {super(e);}
		}
	}
end