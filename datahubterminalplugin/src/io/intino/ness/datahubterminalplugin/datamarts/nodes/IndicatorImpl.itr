def type(indicatorNode & default) trigger(nodeImpl)
	private class IndicatorNodeImpl implements IndicatorNode {
		private final String id;
		private volatile File file;
		private volatile boolean hasDirectAccessToFile;

		private IndicatorNodeImpl(String id, File file) {
			this.id = requireNonNull(id);
			this.file = file;
			this.hasDirectAccessToFile = file != null;
		}

		@Override
		public Indicator get() throws Indicator NotAvailableException {
			synchronized(this) {
				if (disposed) throw new Indicator NotAvailableException("This " + getClass().getSimpleName() + " is disposed.");
				try {
					if (hasDirectAccessToFile) return loadFile(this.file);
					return downloadFromDatahub();
				} catch(Exception e) {
					throw new Indicator NotAvailableException(e);
				}
			}
		}

		public Indicator loadFile(File file) throws IOException {
			Map<String, Shot> shots;
			if (!file.exists()) return new Indicator(new HashMap<>());
			try (var stream = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)))) {
				int size = stream.readInt();
				shots = new HashMap<>(size);
				for (int i = 0; i < size; i++)
					shots.put(stream.readUTF(), new Shot(ofEpochMilli(stream.readLong()), stream.readDouble()));
			}
			return new Indicator(shots);
		}

		private Datamart.Indicator downloadFromDatahub() throws Exception {
			response = requestResponseFromDatahub("get-indicator=" + id(), request("download"));
			if (!response.getBooleanProperty("success")) throw new IndicatorNotAvailableException("Could not get indicator " + id + " because datahub returned success=false in the response");
			return readFromBytes((javax.jms.BytesMessage) response);
		}

		private Datamart.Indicator readFromBytes(javax.jms.BytesMessage m) throws Exception {
			int size = m.getIntProperty("size");
			byte$[$] bytes = new byte$[size$];
			m.readBytes(bytes, size);
			Map<String, Shot> shots;
			try (var stream = new ObjectInputStream(new BufferedInputStream(new ByteArrayInputStream(bytes))))) {
				int size = stream.readInt();
				shots = new HashMap<>(size);
				for (int i = 0; i < size; i++)
					shots.put(stream.readUTF(), new Indicator.Shot(ofEpochMilli(stream.readLong()), stream.readDouble()));
			}
			return new Indicator(shots);
		}
	}
end